<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: sync</title>
<link href="../css/light-v0.5.7.css" rel="stylesheet">
<script src="../jvs/golds-v0.5.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>sync</b></span>

<span class="title">Import Path</span>
	<a href="../index.html#pkg-sync">sync</a><i> (on <a href="https://pkg.go.dev/sync" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../dep/sync.html">4 packages</a>, and imported by <a href="../dep/sync.html#imported-by">86 packages</a>

<div id="files"><span class="title">Involved Source Files</span>

	<span class="nodocs">      <a href="../src/sync/cond.go.html">cond.go</a></span>
	<span class="nodocs">      <a href="../src/sync/map.go.html">map.go</a></span>
	<input type='checkbox' checked class="fold" id="file-2-fold-content"><label for="file-2-fold-content">   <a href="../src/sync/mutex.go.html#doc">#d</a> <a href="../src/sync/mutex.go.html">mutex.go</a></label><span id='file-2-fold-content-items' class="fold-items">
<span class="md-text">		Package sync provides basic synchronization primitives such as mutual
		exclusion locks. Other than the Once and WaitGroup types, most are intended
		for use by low-level library routines. Higher-level synchronization is
		better done via channels and communication.
		
		Values containing the types defined in this package should not be copied.</span>
</span>
	<span class="nodocs">      <a href="../src/sync/once.go.html">once.go</a></span>
	<span class="nodocs">      <a href="../src/sync/pool.go.html">pool.go</a></span>
	<span class="nodocs">      <a href="../src/sync/poolqueue.go.html">poolqueue.go</a></span>
	<span class="nodocs">      <a href="../src/sync/runtime.go.html">runtime.go</a></span>
	<span class="nodocs">      <a href="../src/sync/runtime2.go.html">runtime2.go</a></span>
	<span class="nodocs">      <a href="../src/sync/rwmutex.go.html">rwmutex.go</a></span>
	<span class="nodocs">      <a href="../src/sync/waitgroup.go.html">waitgroup.go</a></span></div>
<div id="examples"><span class="title">Code Examples</span>

	<input type='checkbox' class="fold" id="example-0-fold-content"><label for="example-0-fold-content">Once</label><span id='example-0-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"sync"
		)
		
		func main() {
			var once sync.Once
			onceBody := func() {
				fmt.Println("Only once")
			}
			done := make(chan bool)
			for i := 0; i &lt; 10; i++ {
				go func() {
					once.Do(onceBody)
					done &lt;- true
				}()
			}
			for i := 0; i &lt; 10; i++ {
				&lt;-done
			}
		}
</span>
	<input type='checkbox' class="fold" id="example-1-fold-content"><label for="example-1-fold-content">Pool</label><span id='example-1-fold-content-items' class="fold-items">
		package main
		
		import (
			"bytes"
			"io"
			"os"
			"sync"
			"time"
		)
		
		var bufPool = sync.Pool{
			New: func() any {
				// The Pool's New function should generally only return pointer
				// types, since a pointer can be put into the return interface
				// value without an allocation:
				return new(bytes.Buffer)
			},
		}
		
		// timeNow is a fake version of time.Now for tests.
		func timeNow() time.Time {
			return time.Unix(1136214245, 0)
		}
		
		func Log(w io.Writer, key, val string) {
			b := bufPool.Get().(*bytes.Buffer)
			b.Reset()
			// Replace this with time.Now() in a real logger.
			b.WriteString(timeNow().UTC().Format(time.RFC3339))
			b.WriteByte(' ')
			b.WriteString(key)
			b.WriteByte('=')
			b.WriteString(val)
			w.Write(b.Bytes())
			bufPool.Put(b)
		}
		
		func main() {
			Log(os.Stdout, "path", "/search?q=flowers")
		}
</span>
	<input type='checkbox' class="fold" id="example-2-fold-content"><label for="example-2-fold-content">WaitGroup</label><span id='example-2-fold-content-items' class="fold-items">
		package main
		
		import (
			"sync"
		)
		
		type httpPkg struct{}
		
		func (httpPkg) Get(url string) {}
		
		var http httpPkg
		
		func main() {
			var wg sync.WaitGroup
			var urls = []string{
				"http://www.golang.org/",
				"http://www.google.com/",
				"http://www.example.com/",
			}
			for _, url := range urls {
				// Increment the WaitGroup counter.
				wg.Add(1)
				// Launch a goroutine to fetch the URL.
				go func(url string) {
					// Decrement the counter when the goroutine completes.
					defer wg.Done()
					// Fetch the URL.
					http.Get(url)
				}(url)
			}
			// Wait for all HTTP fetches to complete.
			wg.Wait()
		}
</span>
</div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (total 8)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Cond" data-popularity="225">	<input type='checkbox' class="fold" id="Cond-fold-content"><label for="Cond-fold-content"> type <a href="../src/sync/cond.go.html#line-36">Cond</a> <i>(struct)</i></label><span id='Cond-fold-content-docs' class="fold-docs">
<span class="md-text">		Cond implements a condition variable, a rendezvous point
		for goroutines waiting for or announcing the occurrence
		of an event.
		
		Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
		which must be held when changing the condition and
		when calling the Wait method.
		
		A Cond must not be copied after first use.
		
		In the terminology of the Go memory model, Cond arranges that
		a call to Broadcast or Signal “synchronizes before” any Wait call
		that it unblocks.
		
		For many simple use cases, users will be better off using channels than a
		Cond (Broadcast corresponds to closing a channel, and Signal corresponds to
		sending on a channel).
		
		For more on replacements for sync.Cond, see [Roberto Clapis's series on
		advanced concurrency patterns], as well as [Bryan Mills's talk on concurrency
		patterns].
		
		[Roberto Clapis's series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/
		[Bryan Mills's talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view</span>

		<input type='checkbox' class="fold" id="Cond-fold-fields"><label for="Cond-fold-fields">Fields (<i>only one</i>)</label><span id='Cond-fold-fields-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Cond-fold-field-L"><label for="Cond-fold-field-L"><a href="../src/sync/cond.go.html#line-40">L</a> <i><a href="#name-Locker">Locker</a></i></label><span id='Cond-fold-field-L-docs' class="fold-docs">
<span class="md-text">				L is held while observing or changing the condition</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Cond-fold-methods"><label for="Cond-fold-methods">Methods (<i>total 3</i>)</label><span id='Cond-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Cond-fold-method-Broadcast"><label for="Cond-fold-method-Broadcast">(*Cond) <a href="../src/sync/cond.go.html#line-90">Broadcast</a>()</label><span id='Cond-fold-method-Broadcast-docs' class="fold-docs">
<span class="md-text">				Broadcast wakes all goroutines waiting on c.
				
				It is allowed but not required for the caller to hold c.L
				during the call.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Cond-fold-method-Signal"><label for="Cond-fold-method-Signal">(*Cond) <a href="../src/sync/cond.go.html#line-81">Signal</a>()</label><span id='Cond-fold-method-Signal-docs' class="fold-docs">
<span class="md-text">				Signal wakes one goroutine waiting on c, if there is any.
				
				It is allowed but not required for the caller to hold c.L
				during the call.
				
				Signal() does not affect goroutine scheduling priority; if other goroutines
				are attempting to lock c.L, they may be awoken before a "waiting" goroutine.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Cond-fold-method-Wait"><label for="Cond-fold-method-Wait">(*Cond) <a href="../src/sync/cond.go.html#line-66">Wait</a>()</label><span id='Cond-fold-method-Wait-docs' class="fold-docs">
<span class="md-text">				Wait atomically unlocks c.L and suspends execution
				of the calling goroutine. After later resuming execution,
				Wait locks c.L before returning. Unlike in other systems,
				Wait cannot return unless awoken by Broadcast or Signal.
				
				Because c.L is not locked when Wait first resumes, the caller
				typically cannot assume that the condition is true when
				Wait returns. Instead, the caller should Wait in a loop:
				
					c.L.Lock()
					for !condition() {
					    c.Wait()
					}
					... make use of condition ...
					c.L.Unlock()</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Cond-fold-results"><label for="Cond-fold-results">As Outputs Of (<i>at least one exported</i>)</label><span id='Cond-fold-results-items' class="fold-items"><span>
			func <a href="#name-NewCond">NewCond</a>(l <a href="#name-Locker">Locker</a>) *<b>Cond</b></span></span>

</span></div><div class="anchor type-res" id="name-Locker" data-popularity="960">	<input type='checkbox' class="fold" id="Locker-fold-content"><label for="Locker-fold-content"> type <a href="../src/sync/mutex.go.html#line-40">Locker</a> <b><i>(interface)</i></b></label><span id='Locker-fold-content-docs' class="fold-docs">
<span class="md-text">		A Locker represents an object that can be locked and unlocked.</span>

		<input type='checkbox' class="fold" id="Locker-fold-methods"><label for="Locker-fold-methods">Methods (<i>total 2</i>)</label><span id='Locker-fold-methods-items' class="fold-items"><span>
			<span class="nodocs">( Locker) <a href="../src/sync/mutex.go.html#line-41">Lock</a>()</span></span><span>
			<span class="nodocs">( Locker) <a href="../src/sync/mutex.go.html#line-42">Unlock</a>()</span></span></span>
		<input type='checkbox' class="fold" id="Locker-fold-impledby"><label for="Locker-fold-impledby">Implemented By (<i>at least 5</i>)</label><span id='Locker-fold-impledby-items' class="fold-items"><span>
			*<a href="#name-Mutex">Mutex</a></span><span>
			*<a href="#name-RWMutex">RWMutex</a></span><span>
			*github.com/pkg/sftp.<a href="github.com/pkg/sftp.html#name-Client">Client</a></span><span>
			 github.com/pkg/sftp.<a href="github.com/pkg/sftp.html#name-RequestServer">RequestServer</a></span><span>
			 github.com/pkg/sftp.<a href="github.com/pkg/sftp.html#name-Server">Server</a></span></span>
		<input type='checkbox' class="fold" id="Locker-fold-results"><label for="Locker-fold-results">As Outputs Of (<i>at least one exported</i>)</label><span id='Locker-fold-results-items' class="fold-items"><span>
			func (*<a href="#name-RWMutex">RWMutex</a>).<a href="../src/sync/rwmutex.go.html#line-224">RLocker</a>() <b>Locker</b></span></span>
		<input type='checkbox' class="fold" id="Locker-fold-params"><label for="Locker-fold-params">As Inputs Of (<i>at least one exported</i>)</label><span id='Locker-fold-params-items' class="fold-items"><span>
			func <a href="#name-NewCond">NewCond</a>(l <b>Locker</b>) *<a href="#name-Cond">Cond</a></span></span>

</span></div><div class="anchor type-res" id="name-Map" data-popularity="370">	<input type='checkbox' class="fold" id="Map-fold-content"><label for="Map-fold-content"> type <a href="../src/sync/map.go.html#line-34">Map</a> <i>(struct)</i></label><span id='Map-fold-content-docs' class="fold-docs">
<span class="md-text">		Map is like a Go map[interface{}]interface{} but is safe for concurrent use
		by multiple goroutines without additional locking or coordination.
		Loads, stores, and deletes run in amortized constant time.
		
		The Map type is specialized. Most code should use a plain Go map instead,
		with separate locking or coordination, for better type safety and to make it
		easier to maintain other invariants along with the map content.
		
		The Map type is optimized for two common use cases: (1) when the entry for a given
		key is only ever written once but read many times, as in caches that only grow,
		or (2) when multiple goroutines read, write, and overwrite entries for disjoint
		sets of keys. In these two cases, use of a Map may significantly reduce lock
		contention compared to a Go map paired with a separate Mutex or RWMutex.
		
		The zero Map is empty and ready for use. A Map must not be copied after first use.
		
		In the terminology of the Go memory model, Map arranges that a write operation
		“synchronizes before” any read operation that observes the effect of the write, where
		read and write operations are defined as follows.
		Load, LoadAndDelete, LoadOrStore are read operations;
		Delete, LoadAndDelete, and Store are write operations;
		and LoadOrStore is a write operation when it returns loaded set to false.</span>

		<input type='checkbox' class="fold" id="Map-fold-methods"><label for="Map-fold-methods">Methods (<i>total 6</i>)</label><span id='Map-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Map-fold-method-Delete"><label for="Map-fold-method-Delete">(*Map) <a href="../src/sync/map.go.html#line-300">Delete</a>(key <a href="builtin.html#name-any">any</a>)</label><span id='Map-fold-method-Delete-docs' class="fold-docs">
<span class="md-text">				Delete deletes the value for a key.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Map-fold-method-Load"><label for="Map-fold-method-Load">(*Map) <a href="../src/sync/map.go.html#line-110">Load</a>(key <a href="builtin.html#name-any">any</a>) (value <a href="builtin.html#name-any">any</a>, ok <a href="builtin.html#name-bool">bool</a>)</label><span id='Map-fold-method-Load-docs' class="fold-docs">
<span class="md-text">				Load returns the value stored in the map for a key, or nil if no
				value is present.
				The ok result indicates whether value was found in the map.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Map-fold-method-LoadAndDelete"><label for="Map-fold-method-LoadAndDelete">(*Map) <a href="../src/sync/map.go.html#line-276">LoadAndDelete</a>(key <a href="builtin.html#name-any">any</a>) (value <a href="builtin.html#name-any">any</a>, loaded <a href="builtin.html#name-bool">bool</a>)</label><span id='Map-fold-method-LoadAndDelete-docs' class="fold-docs">
<span class="md-text">				LoadAndDelete deletes the value for a key, returning the previous value if any.
				The loaded result reports whether the key was present.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Map-fold-method-LoadOrStore"><label for="Map-fold-method-LoadOrStore">(*Map) <a href="../src/sync/map.go.html#line-207">LoadOrStore</a>(key, value <a href="builtin.html#name-any">any</a>) (actual <a href="builtin.html#name-any">any</a>, loaded <a href="builtin.html#name-bool">bool</a>)</label><span id='Map-fold-method-LoadOrStore-docs' class="fold-docs">
<span class="md-text">				LoadOrStore returns the existing value for the key if present.
				Otherwise, it stores and returns the given value.
				The loaded result is true if the value was loaded, false if stored.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Map-fold-method-Range"><label for="Map-fold-method-Range">(*Map) <a href="../src/sync/map.go.html#line-327">Range</a>(f func(key, value <a href="builtin.html#name-any">any</a>) <a href="builtin.html#name-bool">bool</a>)</label><span id='Map-fold-method-Range-docs' class="fold-docs">
<span class="md-text">				Range calls f sequentially for each key and value present in the map.
				If f returns false, range stops the iteration.
				
				Range does not necessarily correspond to any consistent snapshot of the Map's
				contents: no key will be visited more than once, but if the value for any key
				is stored or deleted concurrently (including by f), Range may reflect any
				mapping for that key from any point during the Range call. Range does not
				block other methods on the receiver; even f itself may call any method on m.
				
				Range may be O(N) with the number of elements in the map even if f returns
				false after a constant number of calls.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Map-fold-method-Store"><label for="Map-fold-method-Store">(*Map) <a href="../src/sync/map.go.html#line-144">Store</a>(key, value <a href="builtin.html#name-any">any</a>)</label><span id='Map-fold-method-Store-docs' class="fold-docs">
<span class="md-text">				Store sets the value for a key.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Map-fold-params"><label for="Map-fold-params">As Inputs Of (<i>at least 2</i>)</label><span id='Map-fold-params-items' class="fold-items"><span>
			func gorm.io/gorm/schema.<a href="gorm.io/gorm/schema.html#name-Parse">Parse</a>(dest interface{}, cacheStore *<b>Map</b>, namer <a href="gorm.io/gorm/schema.html">schema</a>.<a href="gorm.io/gorm/schema.html#name-Namer">Namer</a>) (*<a href="gorm.io/gorm/schema.html">schema</a>.<a href="gorm.io/gorm/schema.html#name-Schema">Schema</a>, <a href="builtin.html#name-error">error</a>)</span><span>
			func gorm.io/gorm/schema.<a href="gorm.io/gorm/schema.html#name-ParseWithSpecialTableName">ParseWithSpecialTableName</a>(dest interface{}, cacheStore *<b>Map</b>, namer <a href="gorm.io/gorm/schema.html">schema</a>.<a href="gorm.io/gorm/schema.html#name-Namer">Namer</a>, specialTableName <a href="builtin.html#name-string">string</a>) (*<a href="gorm.io/gorm/schema.html">schema</a>.<a href="gorm.io/gorm/schema.html#name-Schema">Schema</a>, <a href="builtin.html#name-error">error</a>)</span></span>

</span></div><div class="anchor type-res" id="name-Mutex" data-popularity="200">	<input type='checkbox' class="fold" id="Mutex-fold-content"><label for="Mutex-fold-content"> type <a href="../src/sync/mutex.go.html#line-34">Mutex</a> <i>(struct)</i></label><span id='Mutex-fold-content-docs' class="fold-docs">
<span class="md-text">		A Mutex is a mutual exclusion lock.
		The zero value for a Mutex is an unlocked mutex.
		
		A Mutex must not be copied after first use.
		
		In the terminology of the Go memory model,
		the n'th call to Unlock “synchronizes before” the m'th call to Lock
		for any n &lt; m.
		A successful call to TryLock is equivalent to a call to Lock.
		A failed call to TryLock does not establish any “synchronizes before”
		relation at all.</span>

		<input type='checkbox' class="fold" id="Mutex-fold-methods"><label for="Mutex-fold-methods">Methods (<i>total 3</i>)</label><span id='Mutex-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Mutex-fold-method-Lock"><label for="Mutex-fold-method-Lock">(*Mutex) <a href="../src/sync/mutex.go.html#line-81">Lock</a>()</label><span id='Mutex-fold-method-Lock-docs' class="fold-docs">
<span class="md-text">				Lock locks m.
				If the lock is already in use, the calling goroutine
				blocks until the mutex is available.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Mutex-fold-method-TryLock"><label for="Mutex-fold-method-TryLock">(*Mutex) <a href="../src/sync/mutex.go.html#line-98">TryLock</a>() <a href="builtin.html#name-bool">bool</a></label><span id='Mutex-fold-method-TryLock-docs' class="fold-docs">
<span class="md-text">				TryLock tries to lock m and reports whether it succeeded.
				
				Note that while correct uses of TryLock do exist, they are rare,
				and use of TryLock is often a sign of a deeper problem
				in a particular use of mutexes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Mutex-fold-method-Unlock"><label for="Mutex-fold-method-Unlock">(*Mutex) <a href="../src/sync/mutex.go.html#line-212">Unlock</a>()</label><span id='Mutex-fold-method-Unlock-docs' class="fold-docs">
<span class="md-text">				Unlock unlocks m.
				It is a run-time error if m is not locked on entry to Unlock.
				
				A locked Mutex is not associated with a particular goroutine.
				It is allowed for one goroutine to lock a Mutex and then
				arrange for another goroutine to unlock it.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Mutex-fold-impls"><label for="Mutex-fold-impls">Implements (<i>at least one exported</i>)</label><span id='Mutex-fold-impls-items' class="fold-items"><span>
			*Mutex : <a href="#name-Locker">Locker</a></span></span>

</span></div><div class="anchor type-res" id="name-Once" data-popularity="50">	<input type='checkbox' class="fold" id="Once-fold-content"><label for="Once-fold-content"> type <a href="../src/sync/once.go.html#line-18">Once</a> <i>(struct)</i></label><span id='Once-fold-content-docs' class="fold-docs">
<span class="md-text">		Once is an object that will perform exactly one action.
		
		A Once must not be copied after first use.
		
		In the terminology of the Go memory model,
		the return from f “synchronizes before”
		the return from any call of once.Do(f).</span>

		<input type='checkbox' class="fold" id="Once-fold-methods"><label for="Once-fold-methods">Methods (<i>only one</i>)</label><span id='Once-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Once-fold-method-Do"><label for="Once-fold-method-Do">(*Once) <a href="../src/sync/once.go.html#line-48">Do</a>(f func())</label><span id='Once-fold-method-Do-docs' class="fold-docs">
<span class="md-text">				Do calls the function f if and only if Do is being called for the
				first time for this instance of Once. In other words, given
				
					var once Once
				
				if once.Do(f) is called multiple times, only the first call will invoke f,
				even if f has a different value in each invocation. A new instance of
				Once is required for each function to execute.
				
				Do is intended for initialization that must be run exactly once. Since f
				is niladic, it may be necessary to use a function literal to capture the
				arguments to a function to be invoked by Do:
				
					config.once.Do(func() { config.init(filename) })
				
				Because no call to Do returns until the one call to f returns, if f causes
				Do to be called, it will deadlock.
				
				If f panics, Do considers it to have returned; future calls of Do return
				without calling f.</span>
</span></span></span>

</span></div><div class="anchor type-res" id="name-Pool" data-popularity="150">	<input type='checkbox' class="fold" id="Pool-fold-content"><label for="Pool-fold-content"> type <a href="../src/sync/pool.go.html#line-49">Pool</a> <i>(struct)</i></label><span id='Pool-fold-content-docs' class="fold-docs">
<span class="md-text">		A Pool is a set of temporary objects that may be individually saved and
		retrieved.
		
		Any item stored in the Pool may be removed automatically at any time without
		notification. If the Pool holds the only reference when this happens, the
		item might be deallocated.
		
		A Pool is safe for use by multiple goroutines simultaneously.
		
		Pool's purpose is to cache allocated but unused items for later reuse,
		relieving pressure on the garbage collector. That is, it makes it easy to
		build efficient, thread-safe free lists. However, it is not suitable for all
		free lists.
		
		An appropriate use of a Pool is to manage a group of temporary items
		silently shared among and potentially reused by concurrent independent
		clients of a package. Pool provides a way to amortize allocation overhead
		across many clients.
		
		An example of good use of a Pool is in the fmt package, which maintains a
		dynamically-sized store of temporary output buffers. The store scales under
		load (when many goroutines are actively printing) and shrinks when
		quiescent.
		
		On the other hand, a free list maintained as part of a short-lived object is
		not a suitable use for a Pool, since the overhead does not amortize well in
		that scenario. It is more efficient to have such objects implement their own
		free list.
		
		A Pool must not be copied after first use.
		
		In the terminology of the Go memory model, a call to Put(x) “synchronizes before”
		a call to Get returning that same value x.
		Similarly, a call to New returning x “synchronizes before”
		a call to Get returning that same value x.</span>

		<input type='checkbox' class="fold" id="Pool-fold-fields"><label for="Pool-fold-fields">Fields (<i>only one</i>)</label><span id='Pool-fold-fields-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Pool-fold-field-New"><label for="Pool-fold-field-New"><a href="../src/sync/pool.go.html#line-61">New</a> <i>func() <a href="builtin.html#name-any">any</a></i></label><span id='Pool-fold-field-New-docs' class="fold-docs">
<span class="md-text">				New optionally specifies a function to generate
				a value when Get would otherwise return nil.
				It may not be changed concurrently with calls to Get.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Pool-fold-methods"><label for="Pool-fold-methods">Methods (<i>total 2</i>)</label><span id='Pool-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Pool-fold-method-Get"><label for="Pool-fold-method-Get">(*Pool) <a href="../src/sync/pool.go.html#line-127">Get</a>() <a href="builtin.html#name-any">any</a></label><span id='Pool-fold-method-Get-docs' class="fold-docs">
<span class="md-text">				Get selects an arbitrary item from the Pool, removes it from the
				Pool, and returns it to the caller.
				Get may choose to ignore the pool and treat it as empty.
				Callers should not assume any relation between values passed to Put and
				the values returned by Get.
				
				If Get would otherwise return nil and p.New is non-nil, Get returns
				the result of calling p.New.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Pool-fold-method-Put"><label for="Pool-fold-method-Put">(*Pool) <a href="../src/sync/pool.go.html#line-95">Put</a>(x <a href="builtin.html#name-any">any</a>)</label><span id='Pool-fold-method-Put-docs' class="fold-docs">
<span class="md-text">				Put adds x to the pool.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Pool-fold-impls"><label for="Pool-fold-impls">Implements (<i>at least one exported</i>)</label><span id='Pool-fold-impls-items' class="fold-items"><span>
			*Pool : gorm.io/gorm/schema.<a href="gorm.io/gorm/schema.html#name-FieldNewValuePool">FieldNewValuePool</a></span></span>

</span></div><div class="anchor type-res" id="name-RWMutex" data-popularity="405">	<input type='checkbox' class="fold" id="RWMutex-fold-content"><label for="RWMutex-fold-content"> type <a href="../src/sync/rwmutex.go.html#line-36">RWMutex</a> <i>(struct)</i></label><span id='RWMutex-fold-content-docs' class="fold-docs">
<span class="md-text">		A RWMutex is a reader/writer mutual exclusion lock.
		The lock can be held by an arbitrary number of readers or a single writer.
		The zero value for a RWMutex is an unlocked mutex.
		
		A RWMutex must not be copied after first use.
		
		If a goroutine holds a RWMutex for reading and another goroutine might
		call Lock, no goroutine should expect to be able to acquire a read lock
		until the initial read lock is released. In particular, this prohibits
		recursive read locking. This is to ensure that the lock eventually becomes
		available; a blocked Lock call excludes new readers from acquiring the
		lock.
		
		In the terminology of the Go memory model,
		the n'th call to Unlock “synchronizes before” the m'th call to Lock
		for any n &lt; m, just as for Mutex.
		For any call to RLock, there exists an n such that
		the n'th call to Unlock “synchronizes before” that call to RLock,
		and the corresponding call to RUnlock “synchronizes before”
		the n+1'th call to Lock.</span>

		<input type='checkbox' class="fold" id="RWMutex-fold-methods"><label for="RWMutex-fold-methods">Methods (<i>total 7</i>)</label><span id='RWMutex-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-Lock"><label for="RWMutex-fold-method-Lock">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-141">Lock</a>()</label><span id='RWMutex-fold-method-Lock-docs' class="fold-docs">
<span class="md-text">				Lock locks rw for writing.
				If the lock is already locked for reading or writing,
				Lock blocks until the lock is available.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-RLock"><label for="RWMutex-fold-method-RLock">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-64">RLock</a>()</label><span id='RWMutex-fold-method-RLock-docs' class="fold-docs">
<span class="md-text">				RLock locks rw for reading.
				
				It should not be used for recursive read locking; a blocked Lock
				call excludes new readers from acquiring the lock. See the
				documentation on the RWMutex type.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-RLocker"><label for="RWMutex-fold-method-RLocker">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-224">RLocker</a>() <a href="#name-Locker">Locker</a></label><span id='RWMutex-fold-method-RLocker-docs' class="fold-docs">
<span class="md-text">				RLocker returns a Locker interface that implements
				the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-RUnlock"><label for="RWMutex-fold-method-RUnlock">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-111">RUnlock</a>()</label><span id='RWMutex-fold-method-RUnlock-docs' class="fold-docs">
<span class="md-text">				RUnlock undoes a single RLock call;
				it does not affect other simultaneous readers.
				It is a run-time error if rw is not locked for reading
				on entry to RUnlock.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-TryLock"><label for="RWMutex-fold-method-TryLock">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-166">TryLock</a>() <a href="builtin.html#name-bool">bool</a></label><span id='RWMutex-fold-method-TryLock-docs' class="fold-docs">
<span class="md-text">				TryLock tries to lock rw for writing and reports whether it succeeded.
				
				Note that while correct uses of TryLock do exist, they are rare,
				and use of TryLock is often a sign of a deeper problem
				in a particular use of mutexes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-TryRLock"><label for="RWMutex-fold-method-TryRLock">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-84">TryRLock</a>() <a href="builtin.html#name-bool">bool</a></label><span id='RWMutex-fold-method-TryRLock-docs' class="fold-docs">
<span class="md-text">				TryRLock tries to lock rw for reading and reports whether it succeeded.
				
				Note that while correct uses of TryRLock do exist, they are rare,
				and use of TryRLock is often a sign of a deeper problem
				in a particular use of mutexes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="RWMutex-fold-method-Unlock"><label for="RWMutex-fold-method-Unlock">(*RWMutex) <a href="../src/sync/rwmutex.go.html#line-198">Unlock</a>()</label><span id='RWMutex-fold-method-Unlock-docs' class="fold-docs">
<span class="md-text">				Unlock unlocks rw for writing. It is a run-time error if rw is
				not locked for writing on entry to Unlock.
				
				As with Mutexes, a locked RWMutex is not associated with a particular
				goroutine. One goroutine may RLock (Lock) a RWMutex and then
				arrange for another goroutine to RUnlock (Unlock) it.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="RWMutex-fold-impls"><label for="RWMutex-fold-impls">Implements (<i>at least one exported</i>)</label><span id='RWMutex-fold-impls-items' class="fold-items"><span>
			*RWMutex : <a href="#name-Locker">Locker</a></span></span>
		<input type='checkbox' class="fold" id="RWMutex-fold-values"><label for="RWMutex-fold-values">As Types Of (<i>only one</i>)</label><span id='RWMutex-fold-values-items' class="fold-items"><span>
			  var syscall.<a href="syscall.html#name-ForkLock">ForkLock</a></span></span>

</span></div><div class="anchor type-res" id="name-WaitGroup" data-popularity="150">	<input type='checkbox' class="fold" id="WaitGroup-fold-content"><label for="WaitGroup-fold-content"> type <a href="../src/sync/waitgroup.go.html#line-23">WaitGroup</a> <i>(struct)</i></label><span id='WaitGroup-fold-content-docs' class="fold-docs">
<span class="md-text">		A WaitGroup waits for a collection of goroutines to finish.
		The main goroutine calls Add to set the number of
		goroutines to wait for. Then each of the goroutines
		runs and calls Done when finished. At the same time,
		Wait can be used to block until all goroutines have finished.
		
		A WaitGroup must not be copied after first use.
		
		In the terminology of the Go memory model, a call to Done
		“synchronizes before” the return of any Wait call that it unblocks.</span>

		<input type='checkbox' class="fold" id="WaitGroup-fold-methods"><label for="WaitGroup-fold-methods">Methods (<i>total 3</i>)</label><span id='WaitGroup-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="WaitGroup-fold-method-Add"><label for="WaitGroup-fold-method-Add">(*WaitGroup) <a href="../src/sync/waitgroup.go.html#line-62">Add</a>(delta <a href="builtin.html#name-int">int</a>)</label><span id='WaitGroup-fold-method-Add-docs' class="fold-docs">
<span class="md-text">				Add adds delta, which may be negative, to the WaitGroup counter.
				If the counter becomes zero, all goroutines blocked on Wait are released.
				If the counter goes negative, Add panics.
				
				Note that calls with a positive delta that occur when the counter is zero
				must happen before a Wait. Calls with a negative delta, or calls with a
				positive delta that start when the counter is greater than zero, may happen
				at any time.
				Typically this means the calls to Add should execute before the statement
				creating the goroutine or other event to be waited for.
				If a WaitGroup is reused to wait for several independent sets of events,
				new Add calls must happen after all previous Wait calls have returned.
				See the WaitGroup example.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="WaitGroup-fold-method-Done"><label for="WaitGroup-fold-method-Done">(*WaitGroup) <a href="../src/sync/waitgroup.go.html#line-107">Done</a>()</label><span id='WaitGroup-fold-method-Done-docs' class="fold-docs">
<span class="md-text">				Done decrements the WaitGroup counter by one.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="WaitGroup-fold-method-Wait"><label for="WaitGroup-fold-method-Wait">(*WaitGroup) <a href="../src/sync/waitgroup.go.html#line-112">Wait</a>()</label><span id='WaitGroup-fold-method-Wait-docs' class="fold-docs">
<span class="md-text">				Wait blocks until the WaitGroup counter is zero.</span>
</span></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (only one)</i></span></span>

<div class="anchor value-res" id="name-NewCond">	<input type='checkbox' class="fold" id="NewCond-fold-content"><label for="NewCond-fold-content"> func <a href="../src/sync/cond.go.html#line-47">NewCond</a>(l <a href="#name-Locker">Locker</a>) *<a href="#name-Cond">Cond</a></label><span id='NewCond-fold-content-docs' class="fold-docs">
<span class="md-text">		NewCond returns a new Cond with Locker l.</span>

</span></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.5.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>