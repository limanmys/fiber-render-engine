<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: regexp</title>
<link href="../css/auto-v0.6.7.css" rel="stylesheet">
<script src="../jvs/golds-v0.6.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>regexp</b></span>

<span class="title">Import Path</span>
	<a href="../index.html#pkg-regexp">regexp</a><i> (on <a href="https://pkg.go.dev/regexp" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../dep/regexp.html">9 packages</a>, and imported by <a href="../dep/regexp.html#imported-by">21 packages</a>

<div id="files"><span class="title">Involved Source Files</span>

	<span class="nodocs">    <a href="../src/regexp/backtrack.go.html">backtrack.go</a></span>
	<span class="nodocs">    <a href="../src/regexp/exec.go.html">exec.go</a></span>
	<span class="nodocs">    <a href="../src/regexp/onepass.go.html">onepass.go</a></span>
	<input type='checkbox' checked class="fold" id="file-3-fold-content"><label for="file-3-fold-content">  <a href="../src/regexp/regexp.go.html#doc">d</a> <a href="../src/regexp/regexp.go.html">regexp.go</a></label><span id='file-3-fold-content-items' class="fold-items">
<span class="md-text">		Package regexp implements regular expression search.
		
		The syntax of the regular expressions accepted is the same
		general syntax used by Perl, Python, and other languages.
		More precisely, it is the syntax accepted by RE2 and described at
		https://golang.org/s/re2syntax, except for \C.
		For an overview of the syntax, run
		
			go doc regexp/syntax
		
		The regexp implementation provided by this package is
		guaranteed to run in time linear in the size of the input.
		(This is a property not guaranteed by most open source
		implementations of regular expressions.) For more information
		about this property, see
		
			https://swtch.com/~rsc/regexp/regexp1.html
		
		or any book about automata theory.
		
		All characters are UTF-8-encoded code points.
		Following utf8.DecodeRune, each byte of an invalid UTF-8 sequence
		is treated as if it encoded utf8.RuneError (U+FFFD).
		
		There are 16 methods of Regexp that match a regular expression and identify
		the matched text. Their names are matched by this regular expression:
		
			Find(All)?(String)?(Submatch)?(Index)?
		
		If 'All' is present, the routine matches successive non-overlapping
		matches of the entire expression. Empty matches abutting a preceding
		match are ignored. The return value is a slice containing the successive
		return values of the corresponding non-'All' routine. These routines take
		an extra integer argument, n. If n &gt;= 0, the function returns at most n
		matches/submatches; otherwise, it returns all of them.
		
		If 'String' is present, the argument is a string; otherwise it is a slice
		of bytes; return values are adjusted as appropriate.
		
		If 'Submatch' is present, the return value is a slice identifying the
		successive submatches of the expression. Submatches are matches of
		parenthesized subexpressions (also known as capturing groups) within the
		regular expression, numbered from left to right in order of opening
		parenthesis. Submatch 0 is the match of the entire expression, submatch 1 is
		the match of the first parenthesized subexpression, and so on.
		
		If 'Index' is present, matches and submatches are identified by byte index
		pairs within the input string: result[2*n:2*n+2] identifies the indexes of
		the nth submatch. The pair for n==0 identifies the match of the entire
		expression. If 'Index' is not present, the match is identified by the text
		of the match/submatch. If an index is negative or text is nil, it means that
		subexpression did not match any string in the input. For 'String' versions
		an empty string means either no match or an empty match.
		
		There is also a subset of the methods that can be applied to text read
		from a RuneReader:
		
			MatchReader, FindReaderIndex, FindReaderSubmatchIndex
		
		This set may grow. Note that regular expression matches may need to
		examine text beyond the text returned by a match, so the methods that
		match text from a RuneReader may read arbitrarily far into the input
		before returning.
		
		(There are a few other methods that do not match this pattern.)</span></span></div>
<div id="examples"><span class="title">Code Examples</span>

	<input type='checkbox' class="fold" id="example-0-fold-content"><label for="example-0-fold-content"></label><span id='example-0-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			// Compile the expression once, usually at init time.
			// Use raw strings to avoid having to quote the backslashes.
			var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)
		
			fmt.Println(validID.MatchString("adam[23]"))
			fmt.Println(validID.MatchString("eve[7]"))
			fmt.Println(validID.MatchString("Job[48]"))
			fmt.Println(validID.MatchString("snakey"))
		}
</span>
	<input type='checkbox' class="fold" id="example-1-fold-content"><label for="example-1-fold-content">Match</label><span id='example-1-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			matched, err := regexp.Match(`foo.*`, []byte(`seafood`))
			fmt.Println(matched, err)
			matched, err = regexp.Match(`bar.*`, []byte(`seafood`))
			fmt.Println(matched, err)
			matched, err = regexp.Match(`a(b`, []byte(`seafood`))
			fmt.Println(matched, err)
		
		}
</span>
	<input type='checkbox' class="fold" id="example-2-fold-content"><label for="example-2-fold-content">MatchString</label><span id='example-2-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			matched, err := regexp.MatchString(`foo.*`, "seafood")
			fmt.Println(matched, err)
			matched, err = regexp.MatchString(`bar.*`, "seafood")
			fmt.Println(matched, err)
			matched, err = regexp.MatchString(`a(b`, "seafood")
			fmt.Println(matched, err)
		}
</span>
	<input type='checkbox' class="fold" id="example-3-fold-content"><label for="example-3-fold-content">QuoteMeta</label><span id='example-3-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			fmt.Println(regexp.QuoteMeta(`Escaping symbols like: .+*?()|[]{}^$`))
		}
</span>
	<input type='checkbox' class="fold" id="example-4-fold-content"><label for="example-4-fold-content">Regexp_Expand</label><span id='example-4-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte(`
			# comment line
			option1: value1
			option2: value2
		
			# another comment line
			option3: value3
		`)
		
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
		
			// Template to convert "key: value" to "key=value" by
			// referencing the values captured by the regex pattern.
			template := []byte("$key=$value\n")
		
			result := []byte{}
		
			// For each match of the regex in the content.
			for _, submatches := range pattern.FindAllSubmatchIndex(content, -1) {
				// Apply the captured submatches to the template and append the output
				// to the result.
				result = pattern.Expand(result, template, content, submatches)
			}
			fmt.Println(string(result))
		}
</span>
	<input type='checkbox' class="fold" id="example-5-fold-content"><label for="example-5-fold-content">Regexp_ExpandString</label><span id='example-5-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := `
			# comment line
			option1: value1
			option2: value2
		
			# another comment line
			option3: value3
		`
		
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
		
			// Template to convert "key: value" to "key=value" by
			// referencing the values captured by the regex pattern.
			template := "$key=$value\n"
		
			result := []byte{}
		
			// For each match of the regex in the content.
			for _, submatches := range pattern.FindAllStringSubmatchIndex(content, -1) {
				// Apply the captured submatches to the template and append the output
				// to the result.
				result = pattern.ExpandString(result, template, content, submatches)
			}
			fmt.Println(string(result))
		}
</span>
	<input type='checkbox' class="fold" id="example-6-fold-content"><label for="example-6-fold-content">Regexp_Find</label><span id='example-6-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Printf("%q\n", re.Find([]byte(`seafood fool`)))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-7-fold-content"><label for="example-7-fold-content">Regexp_FindAll</label><span id='example-7-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Printf("%q\n", re.FindAll([]byte(`seafood fool`), -1))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-8-fold-content"><label for="example-8-fold-content">Regexp_FindAllIndex</label><span id='example-8-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte("London")
			re := regexp.MustCompile(`o.`)
			fmt.Println(re.FindAllIndex(content, 1))
			fmt.Println(re.FindAllIndex(content, -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-9-fold-content"><label for="example-9-fold-content">Regexp_FindAllString</label><span id='example-9-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a.`)
			fmt.Println(re.FindAllString("paranormal", -1))
			fmt.Println(re.FindAllString("paranormal", 2))
			fmt.Println(re.FindAllString("graal", -1))
			fmt.Println(re.FindAllString("none", -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-10-fold-content"><label for="example-10-fold-content">Regexp_FindAllStringSubmatch</label><span id='example-10-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-", -1))
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-", -1))
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-axb-", -1))
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-ab-", -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-11-fold-content"><label for="example-11-fold-content">Regexp_FindAllStringSubmatchIndex</label><span id='example-11-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			// Indices:
			//    01234567   012345678
			//    -ab-axb-   -axxb-ab-
			fmt.Println(re.FindAllStringSubmatchIndex("-ab-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-axxb-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-ab-axb-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-axxb-ab-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-foo-", -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-12-fold-content"><label for="example-12-fold-content">Regexp_FindAllSubmatch</label><span id='example-12-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo(.?)`)
			fmt.Printf("%q\n", re.FindAllSubmatch([]byte(`seafood fool`), -1))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-13-fold-content"><label for="example-13-fold-content">Regexp_FindAllSubmatchIndex</label><span id='example-13-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte(`
			# comment line
			option1: value1
			option2: value2
		`)
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
			allIndexes := pattern.FindAllSubmatchIndex(content, -1)
			for _, loc := range allIndexes {
				fmt.Println(loc)
				fmt.Println(string(content[loc[0]:loc[1]]))
				fmt.Println(string(content[loc[2]:loc[3]]))
				fmt.Println(string(content[loc[4]:loc[5]]))
			}
		}
</span>
	<input type='checkbox' class="fold" id="example-14-fold-content"><label for="example-14-fold-content">Regexp_FindIndex</label><span id='example-14-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte(`
			# comment line
			option1: value1
			option2: value2
		`)
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
		
			loc := pattern.FindIndex(content)
			fmt.Println(loc)
			fmt.Println(string(content[loc[0]:loc[1]]))
		}
</span>
	<input type='checkbox' class="fold" id="example-15-fold-content"><label for="example-15-fold-content">Regexp_FindString</label><span id='example-15-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Printf("%q\n", re.FindString("seafood fool"))
			fmt.Printf("%q\n", re.FindString("meat"))
		}
</span>
	<input type='checkbox' class="fold" id="example-16-fold-content"><label for="example-16-fold-content">Regexp_FindStringIndex</label><span id='example-16-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`ab?`)
			fmt.Println(re.FindStringIndex("tablett"))
			fmt.Println(re.FindStringIndex("foo") == nil)
		}
</span>
	<input type='checkbox' class="fold" id="example-17-fold-content"><label for="example-17-fold-content">Regexp_FindStringSubmatch</label><span id='example-17-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b(y|z)c`)
			fmt.Printf("%q\n", re.FindStringSubmatch("-axxxbyc-"))
			fmt.Printf("%q\n", re.FindStringSubmatch("-abzc-"))
		}
</span>
	<input type='checkbox' class="fold" id="example-18-fold-content"><label for="example-18-fold-content">Regexp_FindSubmatch</label><span id='example-18-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo(.?)`)
			fmt.Printf("%q\n", re.FindSubmatch([]byte(`seafood fool`)))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-19-fold-content"><label for="example-19-fold-content">Regexp_FindSubmatchIndex</label><span id='example-19-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			// Indices:
			//    01234567   012345678
			//    -ab-axb-   -axxb-ab-
			fmt.Println(re.FindSubmatchIndex([]byte("-ab-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-axxb-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-ab-axb-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-axxb-ab-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-foo-")))
		}
</span>
	<input type='checkbox' class="fold" id="example-20-fold-content"><label for="example-20-fold-content">Regexp_Longest</label><span id='example-20-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(|b)`)
			fmt.Println(re.FindString("ab"))
			re.Longest()
			fmt.Println(re.FindString("ab"))
		}
</span>
	<input type='checkbox' class="fold" id="example-21-fold-content"><label for="example-21-fold-content">Regexp_Match</label><span id='example-21-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Println(re.Match([]byte(`seafood fool`)))
			fmt.Println(re.Match([]byte(`something else`)))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-22-fold-content"><label for="example-22-fold-content">Regexp_MatchString</label><span id='example-22-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`(gopher){2}`)
			fmt.Println(re.MatchString("gopher"))
			fmt.Println(re.MatchString("gophergopher"))
			fmt.Println(re.MatchString("gophergophergopher"))
		}
</span>
	<input type='checkbox' class="fold" id="example-23-fold-content"><label for="example-23-fold-content">Regexp_NumSubexp</label><span id='example-23-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re0 := regexp.MustCompile(`a.`)
			fmt.Printf("%d\n", re0.NumSubexp())
		
			re := regexp.MustCompile(`(.*)((a)b)(.*)a`)
			fmt.Println(re.NumSubexp())
		}
</span>
	<input type='checkbox' class="fold" id="example-24-fold-content"><label for="example-24-fold-content">Regexp_ReplaceAll</label><span id='example-24-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("T")))
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("$1")))
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("$1W")))
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("${1}W")))
		}
</span>
	<input type='checkbox' class="fold" id="example-25-fold-content"><label for="example-25-fold-content">Regexp_ReplaceAllLiteralString</label><span id='example-25-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "T"))
			fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "$1"))
			fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "${1}"))
		}
</span>
	<input type='checkbox' class="fold" id="example-26-fold-content"><label for="example-26-fold-content">Regexp_ReplaceAllString</label><span id='example-26-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "T"))
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1"))
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1W"))
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "${1}W"))
		}
</span>
	<input type='checkbox' class="fold" id="example-27-fold-content"><label for="example-27-fold-content">Regexp_ReplaceAllStringFunc</label><span id='example-27-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
			"strings"
		)
		
		func main() {
			re := regexp.MustCompile(`[^aeiou]`)
			fmt.Println(re.ReplaceAllStringFunc("seafood fool", strings.ToUpper))
		}
</span>
	<input type='checkbox' class="fold" id="example-28-fold-content"><label for="example-28-fold-content">Regexp_Split</label><span id='example-28-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			a := regexp.MustCompile(`a`)
			fmt.Println(a.Split("banana", -1))
			fmt.Println(a.Split("banana", 0))
			fmt.Println(a.Split("banana", 1))
			fmt.Println(a.Split("banana", 2))
			zp := regexp.MustCompile(`z+`)
			fmt.Println(zp.Split("pizza", -1))
			fmt.Println(zp.Split("pizza", 0))
			fmt.Println(zp.Split("pizza", 1))
			fmt.Println(zp.Split("pizza", 2))
		}
</span>
	<input type='checkbox' class="fold" id="example-29-fold-content"><label for="example-29-fold-content">Regexp_SubexpIndex</label><span id='example-29-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)`)
			fmt.Println(re.MatchString("Alan Turing"))
			matches := re.FindStringSubmatch("Alan Turing")
			lastIndex := re.SubexpIndex("last")
			fmt.Printf("last =&gt; %d\n", lastIndex)
			fmt.Println(matches[lastIndex])
		}
</span>
	<input type='checkbox' class="fold" id="example-30-fold-content"><label for="example-30-fold-content">Regexp_SubexpNames</label><span id='example-30-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)`)
			fmt.Println(re.MatchString("Alan Turing"))
			fmt.Printf("%q\n", re.SubexpNames())
			reversed := fmt.Sprintf("${%s} ${%s}", re.SubexpNames()[2], re.SubexpNames()[1])
			fmt.Println(reversed)
			fmt.Println(re.ReplaceAllString("Alan Turing", reversed))
		}
</span>
</div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (only one)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Regexp" data-popularity="2560">	<input type='checkbox' class="fold" id="Regexp-fold-content"><label for="Regexp-fold-content"> type <a href="../src/regexp/regexp.go.html#line-86">Regexp</a> <i>(struct)</i></label><span id='Regexp-fold-content-docs' class="fold-docs">
<span class="md-text">		Regexp is the representation of a compiled regular expression.
		A Regexp is safe for concurrent use by multiple goroutines,
		except for configuration methods, such as Longest.</span>

		<input type='checkbox' class="fold" id="Regexp-fold-methods"><label for="Regexp-fold-methods">Methods (<i>total 39</i>)</label><span id='Regexp-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Copy"><label for="Regexp-fold-method-Copy">(*Regexp) <a href="../src/regexp/regexp.go.html#line-121">Copy</a>() *<b>Regexp</b></label><span id='Regexp-fold-method-Copy-docs' class="fold-docs">
<span class="md-text">				Copy returns a new Regexp object copied from re.
				Calling Longest on one copy does not affect another.
				
				Deprecated: In earlier releases, when using a Regexp in multiple goroutines,
				giving each goroutine its own copy helped to avoid lock contention.
				As of Go 1.12, using Copy is no longer necessary to avoid lock contention.
				Copy may still be appropriate if the reason for its use is to make
				two copies with different Longest settings.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Expand"><label for="Regexp-fold-method-Expand">(*Regexp) <a href="../src/regexp/regexp.go.html#line-921">Expand</a>(dst []<a href="builtin.html#name-byte">byte</a>, template []<a href="builtin.html#name-byte">byte</a>, src []<a href="builtin.html#name-byte">byte</a>, match []<a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-Expand-docs' class="fold-docs">
<span class="md-text">				Expand appends template to dst and returns the result; during the
				append, Expand replaces variables in the template with corresponding
				matches drawn from src. The match slice should have been returned by
				FindSubmatchIndex.
				
				In the template, a variable is denoted by a substring of the form
				$name or ${name}, where name is a non-empty sequence of letters,
				digits, and underscores. A purely numeric name like $1 refers to
				the submatch with the corresponding index; other names refer to
				capturing parentheses named with the (?P&lt;name&gt;...) syntax. A
				reference to an out of range or unmatched index or a name that is not
				present in the regular expression is replaced with an empty slice.
				
				In the $name form, name is taken to be as long as possible: $1x is
				equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.
				
				To insert a literal $ in the output, use $$ in the template.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ExpandString"><label for="Regexp-fold-method-ExpandString">(*Regexp) <a href="../src/regexp/regexp.go.html#line-928">ExpandString</a>(dst []<a href="builtin.html#name-byte">byte</a>, template <a href="builtin.html#name-string">string</a>, src <a href="builtin.html#name-string">string</a>, match []<a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ExpandString-docs' class="fold-docs">
<span class="md-text">				ExpandString is like Expand but the template and source are strings.
				It appends to and returns a byte slice in order to give the calling
				code control over allocation.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Find"><label for="Regexp-fold-method-Find">(*Regexp) <a href="../src/regexp/regexp.go.html#line-824">Find</a>(b []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-Find-docs' class="fold-docs">
<span class="md-text">				Find returns a slice holding the text of the leftmost match in b of the regular expression.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAll"><label for="Regexp-fold-method-FindAll">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1083">FindAll</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-FindAll-docs' class="fold-docs">
<span class="md-text">				FindAll is the 'All' version of Find; it returns a slice of all successive
				matches of the expression, as defined by the 'All' description in the
				package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllIndex"><label for="Regexp-fold-method-FindAllIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1101">FindAllIndex</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllIndex-docs' class="fold-docs">
<span class="md-text">				FindAllIndex is the 'All' version of FindIndex; it returns a slice of all
				successive matches of the expression, as defined by the 'All' description
				in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllString"><label for="Regexp-fold-method-FindAllString">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1119">FindAllString</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindAllString-docs' class="fold-docs">
<span class="md-text">				FindAllString is the 'All' version of FindString; it returns a slice of all
				successive matches of the expression, as defined by the 'All' description
				in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllStringIndex"><label for="Regexp-fold-method-FindAllStringIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1137">FindAllStringIndex</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllStringIndex-docs' class="fold-docs">
<span class="md-text">				FindAllStringIndex is the 'All' version of FindStringIndex; it returns a
				slice of all successive matches of the expression, as defined by the 'All'
				description in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllStringSubmatch"><label for="Regexp-fold-method-FindAllStringSubmatch">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1197">FindAllStringSubmatch</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindAllStringSubmatch-docs' class="fold-docs">
<span class="md-text">				FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it
				returns a slice of all successive matches of the expression, as defined by
				the 'All' description in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllStringSubmatchIndex"><label for="Regexp-fold-method-FindAllStringSubmatchIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1222">FindAllStringSubmatchIndex</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllStringSubmatchIndex-docs' class="fold-docs">
<span class="md-text">				FindAllStringSubmatchIndex is the 'All' version of
				FindStringSubmatchIndex; it returns a slice of all successive matches of
				the expression, as defined by the 'All' description in the package
				comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllSubmatch"><label for="Regexp-fold-method-FindAllSubmatch">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1155">FindAllSubmatch</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][][]<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-FindAllSubmatch-docs' class="fold-docs">
<span class="md-text">				FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice
				of all successive matches of the expression, as defined by the 'All'
				description in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllSubmatchIndex"><label for="Regexp-fold-method-FindAllSubmatchIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1179">FindAllSubmatchIndex</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllSubmatchIndex-docs' class="fold-docs">
<span class="md-text">				FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns
				a slice of all successive matches of the expression, as defined by the
				'All' description in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindIndex"><label for="Regexp-fold-method-FindIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-837">FindIndex</a>(b []<a href="builtin.html#name-byte">byte</a>) (loc []<a href="builtin.html#name-int">int</a>)</label><span id='Regexp-fold-method-FindIndex-docs' class="fold-docs">
<span class="md-text">				FindIndex returns a two-element slice of integers defining the location of
				the leftmost match in b of the regular expression. The match itself is at
				b[loc[0]:loc[1]].
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindReaderIndex"><label for="Regexp-fold-method-FindReaderIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-876">FindReaderIndex</a>(r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) (loc []<a href="builtin.html#name-int">int</a>)</label><span id='Regexp-fold-method-FindReaderIndex-docs' class="fold-docs">
<span class="md-text">				FindReaderIndex returns a two-element slice of integers defining the
				location of the leftmost match of the regular expression in text read from
				the RuneReader. The match text was found in the input stream at
				byte offset loc[0] through loc[1]-1.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindReaderSubmatchIndex"><label for="Regexp-fold-method-FindReaderSubmatchIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1073">FindReaderSubmatchIndex</a>(r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) []<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindReaderSubmatchIndex-docs' class="fold-docs">
<span class="md-text">				FindReaderSubmatchIndex returns a slice holding the index pairs
				identifying the leftmost match of the regular expression of text read by
				the RuneReader, and the matches, if any, of its subexpressions, as defined
				by the 'Submatch' and 'Index' descriptions in the package comment. A
				return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindString"><label for="Regexp-fold-method-FindString">(*Regexp) <a href="../src/regexp/regexp.go.html#line-850">FindString</a>(s <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindString-docs' class="fold-docs">
<span class="md-text">				FindString returns a string holding the text of the leftmost match in s of the regular
				expression. If there is no match, the return value is an empty string,
				but it will also be empty if the regular expression successfully matches
				an empty string. Use FindStringIndex or FindStringSubmatch if it is
				necessary to distinguish these cases.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindStringIndex"><label for="Regexp-fold-method-FindStringIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-863">FindStringIndex</a>(s <a href="builtin.html#name-string">string</a>) (loc []<a href="builtin.html#name-int">int</a>)</label><span id='Regexp-fold-method-FindStringIndex-docs' class="fold-docs">
<span class="md-text">				FindStringIndex returns a two-element slice of integers defining the
				location of the leftmost match in s of the regular expression. The match
				itself is at s[loc[0]:loc[1]].
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindStringSubmatch"><label for="Regexp-fold-method-FindStringSubmatch">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1044">FindStringSubmatch</a>(s <a href="builtin.html#name-string">string</a>) []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindStringSubmatch-docs' class="fold-docs">
<span class="md-text">				FindStringSubmatch returns a slice of strings holding the text of the
				leftmost match of the regular expression in s and the matches, if any, of
				its subexpressions, as defined by the 'Submatch' description in the
				package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindStringSubmatchIndex"><label for="Regexp-fold-method-FindStringSubmatchIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1064">FindStringSubmatchIndex</a>(s <a href="builtin.html#name-string">string</a>) []<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindStringSubmatchIndex-docs' class="fold-docs">
<span class="md-text">				FindStringSubmatchIndex returns a slice holding the index pairs
				identifying the leftmost match of the regular expression in s and the
				matches, if any, of its subexpressions, as defined by the 'Submatch' and
				'Index' descriptions in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindSubmatch"><label for="Regexp-fold-method-FindSubmatch">(*Regexp) <a href="../src/regexp/regexp.go.html#line-889">FindSubmatch</a>(b []<a href="builtin.html#name-byte">byte</a>) [][]<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-FindSubmatch-docs' class="fold-docs">
<span class="md-text">				FindSubmatch returns a slice of slices holding the text of the leftmost
				match of the regular expression in b and the matches, if any, of its
				subexpressions, as defined by the 'Submatch' descriptions in the package
				comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindSubmatchIndex"><label for="Regexp-fold-method-FindSubmatchIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1035">FindSubmatchIndex</a>(b []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindSubmatchIndex-docs' class="fold-docs">
<span class="md-text">				FindSubmatchIndex returns a slice holding the index pairs identifying the
				leftmost match of the regular expression in b and the matches, if any, of
				its subexpressions, as defined by the 'Submatch' and 'Index' descriptions
				in the package comment.
				A return value of nil indicates no match.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-LiteralPrefix"><label for="Regexp-fold-method-LiteralPrefix">(*Regexp) <a href="../src/regexp/regexp.go.html#line-520">LiteralPrefix</a>() (prefix <a href="builtin.html#name-string">string</a>, complete <a href="builtin.html#name-bool">bool</a>)</label><span id='Regexp-fold-method-LiteralPrefix-docs' class="fold-docs">
<span class="md-text">				LiteralPrefix returns a literal string that must begin any match
				of the regular expression re. It returns the boolean true if the
				literal string comprises the entire regular expression.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Longest"><label for="Regexp-fold-method-Longest">(*Regexp) <a href="../src/regexp/regexp.go.html#line-169">Longest</a>()</label><span id='Regexp-fold-method-Longest-docs' class="fold-docs">
<span class="md-text">				Longest makes future searches prefer the leftmost-longest match.
				That is, when matching against text, the regexp returns a match that
				begins as early as possible in the input (leftmost), and among those
				it chooses a match that is as long as possible.
				This method modifies the Regexp and may not be called concurrently
				with any other methods.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-MarshalText"><label for="Regexp-fold-method-MarshalText">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1293">MarshalText</a>() ([]<a href="builtin.html#name-byte">byte</a>, <a href="builtin.html#name-error">error</a>)</label><span id='Regexp-fold-method-MarshalText-docs' class="fold-docs">
<span class="md-text">				MarshalText implements [encoding.TextMarshaler]. The output
				matches that of calling the [Regexp.String] method.
				
				Note that the output is lossy in some cases: This method does not indicate
				POSIX regular expressions (i.e. those compiled by calling [CompilePOSIX]), or
				those for which the [Regexp.Longest] method has been called.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Match"><label for="Regexp-fold-method-Match">(*Regexp) <a href="../src/regexp/regexp.go.html#line-538">Match</a>(b []<a href="builtin.html#name-byte">byte</a>) <a href="builtin.html#name-bool">bool</a></label><span id='Regexp-fold-method-Match-docs' class="fold-docs">
<span class="md-text">				Match reports whether the byte slice b
				contains any match of the regular expression re.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-MatchReader"><label for="Regexp-fold-method-MatchReader">(*Regexp) <a href="../src/regexp/regexp.go.html#line-526">MatchReader</a>(r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) <a href="builtin.html#name-bool">bool</a></label><span id='Regexp-fold-method-MatchReader-docs' class="fold-docs">
<span class="md-text">				MatchReader reports whether the text returned by the RuneReader
				contains any match of the regular expression re.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-MatchString"><label for="Regexp-fold-method-MatchString">(*Regexp) <a href="../src/regexp/regexp.go.html#line-532">MatchString</a>(s <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-bool">bool</a></label><span id='Regexp-fold-method-MatchString-docs' class="fold-docs">
<span class="md-text">				MatchString reports whether the string s
				contains any match of the regular expression re.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-NumSubexp"><label for="Regexp-fold-method-NumSubexp">(*Regexp) <a href="../src/regexp/regexp.go.html#line-343">NumSubexp</a>() <a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-NumSubexp-docs' class="fold-docs">
<span class="md-text">				NumSubexp returns the number of parenthesized subexpressions in this Regexp.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAll"><label for="Regexp-fold-method-ReplaceAll">(*Regexp) <a href="../src/regexp/regexp.go.html#line-677">ReplaceAll</a>(src, repl []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ReplaceAll-docs' class="fold-docs">
<span class="md-text">				ReplaceAll returns a copy of src, replacing matches of the Regexp
				with the replacement text repl. Inside repl, $ signs are interpreted as
				in Expand, so for instance $1 represents the text of the first submatch.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllFunc"><label for="Regexp-fold-method-ReplaceAllFunc">(*Regexp) <a href="../src/regexp/regexp.go.html#line-705">ReplaceAllFunc</a>(src []<a href="builtin.html#name-byte">byte</a>, repl func([]<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ReplaceAllFunc-docs' class="fold-docs">
<span class="md-text">				ReplaceAllFunc returns a copy of src in which all matches of the
				Regexp have been replaced by the return value of function repl applied
				to the matched byte slice. The replacement returned by repl is substituted
				directly, without using Expand.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllLiteral"><label for="Regexp-fold-method-ReplaceAllLiteral">(*Regexp) <a href="../src/regexp/regexp.go.html#line-695">ReplaceAllLiteral</a>(src, repl []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ReplaceAllLiteral-docs' class="fold-docs">
<span class="md-text">				ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp
				with the replacement bytes repl. The replacement repl is substituted directly,
				without using Expand.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllLiteralString"><label for="Regexp-fold-method-ReplaceAllLiteralString">(*Regexp) <a href="../src/regexp/regexp.go.html#line-592">ReplaceAllLiteralString</a>(src, repl <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-ReplaceAllLiteralString-docs' class="fold-docs">
<span class="md-text">				ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp
				with the replacement string repl. The replacement repl is substituted directly,
				without using Expand.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllString"><label for="Regexp-fold-method-ReplaceAllString">(*Regexp) <a href="../src/regexp/regexp.go.html#line-578">ReplaceAllString</a>(src, repl <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-ReplaceAllString-docs' class="fold-docs">
<span class="md-text">				ReplaceAllString returns a copy of src, replacing matches of the Regexp
				with the replacement string repl. Inside repl, $ signs are interpreted as
				in Expand, so for instance $1 represents the text of the first submatch.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllStringFunc"><label for="Regexp-fold-method-ReplaceAllStringFunc">(*Regexp) <a href="../src/regexp/regexp.go.html#line-602">ReplaceAllStringFunc</a>(src <a href="builtin.html#name-string">string</a>, repl func(<a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-ReplaceAllStringFunc-docs' class="fold-docs">
<span class="md-text">				ReplaceAllStringFunc returns a copy of src in which all matches of the
				Regexp have been replaced by the return value of function repl applied
				to the matched substring. The replacement returned by repl is substituted
				directly, without using Expand.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Split"><label for="Regexp-fold-method-Split">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1253">Split</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-Split-docs' class="fold-docs">
<span class="md-text">				Split slices s into substrings separated by the expression and returns a slice of
				the substrings between those expression matches.
				
				The slice returned by this method consists of all the substrings of s
				not contained in the slice returned by FindAllString. When called on an expression
				that contains no metacharacters, it is equivalent to strings.SplitN.
				
				Example:
				
					s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
					// s: ["", "b", "b", "c", "cadaaae"]
				
				The count determines the number of substrings to return:
				
					n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
					n == 0: the result is nil (zero substrings)
					n &lt; 0: all substrings</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-String"><label for="Regexp-fold-method-String">(*Regexp) <a href="../src/regexp/regexp.go.html#line-109">String</a>() <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-String-docs' class="fold-docs">
<span class="md-text">				String returns the source text used to compile the regular expression.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-SubexpIndex"><label for="Regexp-fold-method-SubexpIndex">(*Regexp) <a href="../src/regexp/regexp.go.html#line-363">SubexpIndex</a>(name <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-SubexpIndex-docs' class="fold-docs">
<span class="md-text">				SubexpIndex returns the index of the first subexpression with the given name,
				or -1 if there is no subexpression with that name.
				
				Note that multiple subexpressions can be written using the same name, as in
				(?P&lt;bob&gt;a+)(?P&lt;bob&gt;b+), which declares two subexpressions named "bob".
				In this case, SubexpIndex returns the index of the leftmost such subexpression
				in the regular expression.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-SubexpNames"><label for="Regexp-fold-method-SubexpNames">(*Regexp) <a href="../src/regexp/regexp.go.html#line-352">SubexpNames</a>() []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-SubexpNames-docs' class="fold-docs">
<span class="md-text">				SubexpNames returns the names of the parenthesized subexpressions
				in this Regexp. The name for the first sub-expression is names[1],
				so that if m is a match slice, the name for m[i] is SubexpNames()[i].
				Since the Regexp as a whole cannot be named, names[0] is always
				the empty string. The slice should not be modified.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-UnmarshalText"><label for="Regexp-fold-method-UnmarshalText">(*Regexp) <a href="../src/regexp/regexp.go.html#line-1299">UnmarshalText</a>(text []<a href="builtin.html#name-byte">byte</a>) <a href="builtin.html#name-error">error</a></label><span id='Regexp-fold-method-UnmarshalText-docs' class="fold-docs">
<span class="md-text">				UnmarshalText implements [encoding.TextUnmarshaler] by calling
				[Compile] on the encoded value.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Regexp-fold-impls"><label for="Regexp-fold-impls">Implements (<i>at least 4</i>)</label><span id='Regexp-fold-impls-items' class="fold-items"><span>
			*Regexp : encoding.<a href="encoding.html#name-TextMarshaler">TextMarshaler</a></span><span>
			*Regexp : encoding.<a href="encoding.html#name-TextUnmarshaler">TextUnmarshaler</a></span><span>
			*Regexp : fmt.<a href="fmt.html#name-Stringer">Stringer</a></span><span>
			*Regexp : github.com/ChrisTrenkamp/goxpath/tree.<a href="github.com/ChrisTrenkamp^c5a4f/goxpath/tree.html#name-Result">Result</a></span></span>
		<input type='checkbox' class="fold" id="Regexp-fold-results"><label for="Regexp-fold-results">As Outputs Of (<i>at least 5</i>)</label><span id='Regexp-fold-results-items' class="fold-items"><span>
			func <a href="#name-Compile">Compile</a>(expr <a href="builtin.html#name-string">string</a>) (*<b>Regexp</b>, <a href="builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-CompilePOSIX">CompilePOSIX</a>(expr <a href="builtin.html#name-string">string</a>) (*<b>Regexp</b>, <a href="builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-MustCompile">MustCompile</a>(str <a href="builtin.html#name-string">string</a>) *<b>Regexp</b></span><span>
			func <a href="#name-MustCompilePOSIX">MustCompilePOSIX</a>(str <a href="builtin.html#name-string">string</a>) *<b>Regexp</b></span><span>
			func (*Regexp).<a href="../src/regexp/regexp.go.html#line-121">Copy</a>() *<b>Regexp</b></span></span>
		<input type='checkbox' class="fold" id="Regexp-fold-params"><label for="Regexp-fold-params">As Inputs Of (<i>at least one exported</i>)</label><span id='Regexp-fold-params-items' class="fold-items"><span>
			func gorm.io/gorm/logger.<a href="gorm.io/gorm/logger.html#name-ExplainSQL">ExplainSQL</a>(sql <a href="builtin.html#name-string">string</a>, numericPlaceholder *<b>Regexp</b>, escaper <a href="builtin.html#name-string">string</a>, avars ...interface{}) <a href="builtin.html#name-string">string</a></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 8)</i></span></span>

<div class="anchor value-res" id="name-Compile">	<input type='checkbox' class="fold" id="Compile-fold-content"><label for="Compile-fold-content"> func <a href="../src/regexp/regexp.go.html#line-136">Compile</a>(expr <a href="builtin.html#name-string">string</a>) (*<a href="#name-Regexp">Regexp</a>, <a href="builtin.html#name-error">error</a>)</label><span id='Compile-fold-content-docs' class="fold-docs">
<span class="md-text">		Compile parses a regular expression and returns, if successful,
		a Regexp object that can be used to match against text.
		
		When matching against text, the regexp returns a match that
		begins as early as possible in the input (leftmost), and among those
		it chooses the one that a backtracking search would have found first.
		This so-called leftmost-first matching is the same semantics
		that Perl, Python, and other implementations use, although this
		package implements it without the expense of backtracking.
		For POSIX leftmost-longest matching, see CompilePOSIX.</span>

</span></div><div class="anchor value-res" id="name-CompilePOSIX">	<input type='checkbox' class="fold" id="CompilePOSIX-fold-content"><label for="CompilePOSIX-fold-content"> func <a href="../src/regexp/regexp.go.html#line-159">CompilePOSIX</a>(expr <a href="builtin.html#name-string">string</a>) (*<a href="#name-Regexp">Regexp</a>, <a href="builtin.html#name-error">error</a>)</label><span id='CompilePOSIX-fold-content-docs' class="fold-docs">
<span class="md-text">		CompilePOSIX is like Compile but restricts the regular expression
		to POSIX ERE (egrep) syntax and changes the match semantics to
		leftmost-longest.
		
		That is, when matching against text, the regexp returns a match that
		begins as early as possible in the input (leftmost), and among those
		it chooses a match that is as long as possible.
		This so-called leftmost-longest matching is the same semantics
		that early regular expression implementations used and that POSIX
		specifies.
		
		However, there can be multiple leftmost-longest matches, with different
		submatch choices, and here this package diverges from POSIX.
		Among the possible leftmost-longest matches, this package chooses
		the one that a backtracking search would have found first, while POSIX
		specifies that the match be chosen to maximize the length of the first
		subexpression, then the second, and so on from left to right.
		The POSIX rule is computationally prohibitive and not even well-defined.
		See https://swtch.com/~rsc/regexp/regexp2.html#posix for details.</span>

</span></div><div class="anchor value-res" id="name-Match">	<input type='checkbox' class="fold" id="Match-fold-content"><label for="Match-fold-content"> func <a href="../src/regexp/regexp.go.html#line-567">Match</a>(pattern <a href="builtin.html#name-string">string</a>, b []<a href="builtin.html#name-byte">byte</a>) (matched <a href="builtin.html#name-bool">bool</a>, err <a href="builtin.html#name-error">error</a>)</label><span id='Match-fold-content-docs' class="fold-docs">
<span class="md-text">		Match reports whether the byte slice b
		contains any match of the regular expression pattern.
		More complicated queries need to use Compile and the full Regexp interface.</span>

</span></div><div class="anchor value-res" id="name-MatchReader">	<input type='checkbox' class="fold" id="MatchReader-fold-content"><label for="MatchReader-fold-content"> func <a href="../src/regexp/regexp.go.html#line-545">MatchReader</a>(pattern <a href="builtin.html#name-string">string</a>, r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) (matched <a href="builtin.html#name-bool">bool</a>, err <a href="builtin.html#name-error">error</a>)</label><span id='MatchReader-fold-content-docs' class="fold-docs">
<span class="md-text">		MatchReader reports whether the text returned by the RuneReader
		contains any match of the regular expression pattern.
		More complicated queries need to use Compile and the full Regexp interface.</span>

</span></div><div class="anchor value-res" id="name-MatchString">	<input type='checkbox' class="fold" id="MatchString-fold-content"><label for="MatchString-fold-content"> func <a href="../src/regexp/regexp.go.html#line-556">MatchString</a>(pattern <a href="builtin.html#name-string">string</a>, s <a href="builtin.html#name-string">string</a>) (matched <a href="builtin.html#name-bool">bool</a>, err <a href="builtin.html#name-error">error</a>)</label><span id='MatchString-fold-content-docs' class="fold-docs">
<span class="md-text">		MatchString reports whether the string s
		contains any match of the regular expression pattern.
		More complicated queries need to use Compile and the full Regexp interface.</span>

</span></div><div class="anchor value-res" id="name-MustCompile">	<input type='checkbox' class="fold" id="MustCompile-fold-content"><label for="MustCompile-fold-content"> func <a href="../src/regexp/regexp.go.html#line-316">MustCompile</a>(str <a href="builtin.html#name-string">string</a>) *<a href="#name-Regexp">Regexp</a></label><span id='MustCompile-fold-content-docs' class="fold-docs">
<span class="md-text">		MustCompile is like Compile but panics if the expression cannot be parsed.
		It simplifies safe initialization of global variables holding compiled regular
		expressions.</span>

</span></div><div class="anchor value-res" id="name-MustCompilePOSIX">	<input type='checkbox' class="fold" id="MustCompilePOSIX-fold-content"><label for="MustCompilePOSIX-fold-content"> func <a href="../src/regexp/regexp.go.html#line-327">MustCompilePOSIX</a>(str <a href="builtin.html#name-string">string</a>) *<a href="#name-Regexp">Regexp</a></label><span id='MustCompilePOSIX-fold-content-docs' class="fold-docs">
<span class="md-text">		MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.
		It simplifies safe initialization of global variables holding compiled regular
		expressions.</span>

</span></div><div class="anchor value-res" id="name-QuoteMeta">	<input type='checkbox' class="fold" id="QuoteMeta-fold-content"><label for="QuoteMeta-fold-content"> func <a href="../src/regexp/regexp.go.html#line-728">QuoteMeta</a>(s <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='QuoteMeta-fold-content-docs' class="fold-docs">
<span class="md-text">		QuoteMeta returns a string that escapes all regular expression metacharacters
		inside the argument text; the returned string is a regular expression matching
		the literal text.</span>

</span></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>