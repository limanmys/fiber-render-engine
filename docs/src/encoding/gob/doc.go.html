<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package encoding/gob</title>
<link href="../../../css/auto-v0.6.7.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/gob.html">encoding/gob</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></code></span>
<span class="codeline" id="line-2"><code><span class="comment">// Use of this source code is governed by a BSD-style</span></code></span>
<span class="codeline" id="line-3"><code><span class="comment">// license that can be found in the LICENSE file.</span></code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code><span class="comment">/*</span></code></span>
<span class="codeline" id="line-6"><code><span class="comment">Package gob manages streams of gobs - binary values exchanged between an</span></code></span>
<span class="codeline" id="line-7"><code><span class="comment">Encoder (transmitter) and a Decoder (receiver). A typical use is transporting</span></code></span>
<span class="codeline" id="line-8"><code><span class="comment">arguments and results of remote procedure calls (RPCs) such as those provided by</span></code></span>
<span class="codeline" id="line-9"><code><span class="comment">[net/rpc].</span></code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code><span class="comment">The implementation compiles a custom codec for each data type in the stream and</span></code></span>
<span class="codeline" id="line-12"><code><span class="comment">is most efficient when a single Encoder is used to transmit a stream of values,</span></code></span>
<span class="codeline" id="line-13"><code><span class="comment">amortizing the cost of compilation.</span></code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code><span class="comment"># Basics</span></code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code><span class="comment">A stream of gobs is self-describing. Each data item in the stream is preceded by</span></code></span>
<span class="codeline" id="line-18"><code><span class="comment">a specification of its type, expressed in terms of a small set of predefined</span></code></span>
<span class="codeline" id="line-19"><code><span class="comment">types. Pointers are not transmitted, but the things they point to are</span></code></span>
<span class="codeline" id="line-20"><code><span class="comment">transmitted; that is, the values are flattened. Nil pointers are not permitted,</span></code></span>
<span class="codeline" id="line-21"><code><span class="comment">as they have no value. Recursive types work fine, but</span></code></span>
<span class="codeline" id="line-22"><code><span class="comment">recursive values (data with cycles) are problematic. This may change.</span></code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code><span class="comment">To use gobs, create an Encoder and present it with a series of data items as</span></code></span>
<span class="codeline" id="line-25"><code><span class="comment">values or addresses that can be dereferenced to values. The Encoder makes sure</span></code></span>
<span class="codeline" id="line-26"><code><span class="comment">all type information is sent before it is needed. At the receive side, a</span></code></span>
<span class="codeline" id="line-27"><code><span class="comment">Decoder retrieves values from the encoded stream and unpacks them into local</span></code></span>
<span class="codeline" id="line-28"><code><span class="comment">variables.</span></code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code><span class="comment"># Types and Values</span></code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code><span class="comment">The source and destination values/types need not correspond exactly. For structs,</span></code></span>
<span class="codeline" id="line-33"><code><span class="comment">fields (identified by name) that are in the source but absent from the receiving</span></code></span>
<span class="codeline" id="line-34"><code><span class="comment">variable will be ignored. Fields that are in the receiving variable but missing</span></code></span>
<span class="codeline" id="line-35"><code><span class="comment">from the transmitted type or value will be ignored in the destination. If a field</span></code></span>
<span class="codeline" id="line-36"><code><span class="comment">with the same name is present in both, their types must be compatible. Both the</span></code></span>
<span class="codeline" id="line-37"><code><span class="comment">receiver and transmitter will do all necessary indirection and dereferencing to</span></code></span>
<span class="codeline" id="line-38"><code><span class="comment">convert between gobs and actual Go values. For instance, a gob type that is</span></code></span>
<span class="codeline" id="line-39"><code><span class="comment">schematically,</span></code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code><span class="comment">	struct { A, B int }</span></code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code><span class="comment">can be sent from or received into any of these Go types:</span></code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code><span class="comment">	struct { A, B int }	// the same</span></code></span>
<span class="codeline" id="line-46"><code><span class="comment">	*struct { A, B int }	// extra indirection of the struct</span></code></span>
<span class="codeline" id="line-47"><code><span class="comment">	struct { *A, **B int }	// extra indirection of the fields</span></code></span>
<span class="codeline" id="line-48"><code><span class="comment">	struct { A, B int64 }	// different concrete value type; see below</span></code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code><span class="comment">It may also be received into any of these:</span></code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code><span class="comment">	struct { A, B int }	// the same</span></code></span>
<span class="codeline" id="line-53"><code><span class="comment">	struct { B, A int }	// ordering doesn't matter; matching is by name</span></code></span>
<span class="codeline" id="line-54"><code><span class="comment">	struct { A, B, C int }	// extra field (C) ignored</span></code></span>
<span class="codeline" id="line-55"><code><span class="comment">	struct { B int }	// missing field (A) ignored; data will be dropped</span></code></span>
<span class="codeline" id="line-56"><code><span class="comment">	struct { B, C int }	// missing field (A) ignored; extra field (C) ignored.</span></code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code><span class="comment">Attempting to receive into these types will draw a decode error:</span></code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code><span class="comment">	struct { A int; B uint }	// change of signedness for B</span></code></span>
<span class="codeline" id="line-61"><code><span class="comment">	struct { A int; B float }	// change of type for B</span></code></span>
<span class="codeline" id="line-62"><code><span class="comment">	struct { }			// no field names in common</span></code></span>
<span class="codeline" id="line-63"><code><span class="comment">	struct { C, D int }		// no field names in common</span></code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code><span class="comment">Integers are transmitted two ways: arbitrary precision signed integers or</span></code></span>
<span class="codeline" id="line-66"><code><span class="comment">arbitrary precision unsigned integers. There is no int8, int16 etc.</span></code></span>
<span class="codeline" id="line-67"><code><span class="comment">discrimination in the gob format; there are only signed and unsigned integers. As</span></code></span>
<span class="codeline" id="line-68"><code><span class="comment">described below, the transmitter sends the value in a variable-length encoding;</span></code></span>
<span class="codeline" id="line-69"><code><span class="comment">the receiver accepts the value and stores it in the destination variable.</span></code></span>
<span class="codeline" id="line-70"><code><span class="comment">Floating-point numbers are always sent using IEEE-754 64-bit precision (see</span></code></span>
<span class="codeline" id="line-71"><code><span class="comment">below).</span></code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code><span class="comment">Signed integers may be received into any signed integer variable: int, int16, etc.;</span></code></span>
<span class="codeline" id="line-74"><code><span class="comment">unsigned integers may be received into any unsigned integer variable; and floating</span></code></span>
<span class="codeline" id="line-75"><code><span class="comment">point values may be received into any floating point variable. However,</span></code></span>
<span class="codeline" id="line-76"><code><span class="comment">the destination variable must be able to represent the value or the decode</span></code></span>
<span class="codeline" id="line-77"><code><span class="comment">operation will fail.</span></code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code><span class="comment">Structs, arrays and slices are also supported. Structs encode and decode only</span></code></span>
<span class="codeline" id="line-80"><code><span class="comment">exported fields. Strings and arrays of bytes are supported with a special,</span></code></span>
<span class="codeline" id="line-81"><code><span class="comment">efficient representation (see below). When a slice is decoded, if the existing</span></code></span>
<span class="codeline" id="line-82"><code><span class="comment">slice has capacity the slice will be extended in place; if not, a new array is</span></code></span>
<span class="codeline" id="line-83"><code><span class="comment">allocated. Regardless, the length of the resulting slice reports the number of</span></code></span>
<span class="codeline" id="line-84"><code><span class="comment">elements decoded.</span></code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code><span class="comment">In general, if allocation is required, the decoder will allocate memory. If not,</span></code></span>
<span class="codeline" id="line-87"><code><span class="comment">it will update the destination variables with values read from the stream. It does</span></code></span>
<span class="codeline" id="line-88"><code><span class="comment">not initialize them first, so if the destination is a compound value such as a</span></code></span>
<span class="codeline" id="line-89"><code><span class="comment">map, struct, or slice, the decoded values will be merged elementwise into the</span></code></span>
<span class="codeline" id="line-90"><code><span class="comment">existing variables.</span></code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code><span class="comment">Functions and channels will not be sent in a gob. Attempting to encode such a value</span></code></span>
<span class="codeline" id="line-93"><code><span class="comment">at the top level will fail. A struct field of chan or func type is treated exactly</span></code></span>
<span class="codeline" id="line-94"><code><span class="comment">like an unexported field and is ignored.</span></code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code><span class="comment">Gob can encode a value of any type implementing the GobEncoder or</span></code></span>
<span class="codeline" id="line-97"><code><span class="comment">encoding.BinaryMarshaler interfaces by calling the corresponding method,</span></code></span>
<span class="codeline" id="line-98"><code><span class="comment">in that order of preference.</span></code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code><span class="comment">Gob can decode a value of any type implementing the GobDecoder or</span></code></span>
<span class="codeline" id="line-101"><code><span class="comment">encoding.BinaryUnmarshaler interfaces by calling the corresponding method,</span></code></span>
<span class="codeline" id="line-102"><code><span class="comment">again in that order of preference.</span></code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code><span class="comment"># Encoding Details</span></code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code><span class="comment">This section documents the encoding, details that are not important for most</span></code></span>
<span class="codeline" id="line-107"><code><span class="comment">users. Details are presented bottom-up.</span></code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code><span class="comment">An unsigned integer is sent one of two ways. If it is less than 128, it is sent</span></code></span>
<span class="codeline" id="line-110"><code><span class="comment">as a byte with that value. Otherwise it is sent as a minimal-length big-endian</span></code></span>
<span class="codeline" id="line-111"><code><span class="comment">(high byte first) byte stream holding the value, preceded by one byte holding the</span></code></span>
<span class="codeline" id="line-112"><code><span class="comment">byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and</span></code></span>
<span class="codeline" id="line-113"><code><span class="comment">256 is transmitted as (FE 01 00).</span></code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code><span class="comment">A boolean is encoded within an unsigned integer: 0 for false, 1 for true.</span></code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code><span class="comment">A signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1</span></code></span>
<span class="codeline" id="line-118"><code><span class="comment">upward contain the value; bit 0 says whether they should be complemented upon</span></code></span>
<span class="codeline" id="line-119"><code><span class="comment">receipt. The encode algorithm looks like this:</span></code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code><span class="comment">	var u uint</span></code></span>
<span class="codeline" id="line-122"><code><span class="comment">	if i &lt; 0 {</span></code></span>
<span class="codeline" id="line-123"><code><span class="comment">		u = (^uint(i) &lt;&lt; 1) | 1 // complement i, bit 0 is 1</span></code></span>
<span class="codeline" id="line-124"><code><span class="comment">	} else {</span></code></span>
<span class="codeline" id="line-125"><code><span class="comment">		u = (uint(i) &lt;&lt; 1) // do not complement i, bit 0 is 0</span></code></span>
<span class="codeline" id="line-126"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-127"><code><span class="comment">	encodeUnsigned(u)</span></code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code><span class="comment">The low bit is therefore analogous to a sign bit, but making it the complement bit</span></code></span>
<span class="codeline" id="line-130"><code><span class="comment">instead guarantees that the largest negative integer is not a special case. For</span></code></span>
<span class="codeline" id="line-131"><code><span class="comment">example, -129=^128=(^256&gt;&gt;1) encodes as (FE 01 01).</span></code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code><span class="comment">Floating-point numbers are always sent as a representation of a float64 value.</span></code></span>
<span class="codeline" id="line-134"><code><span class="comment">That value is converted to a uint64 using math.Float64bits. The uint64 is then</span></code></span>
<span class="codeline" id="line-135"><code><span class="comment">byte-reversed and sent as a regular unsigned integer. The byte-reversal means the</span></code></span>
<span class="codeline" id="line-136"><code><span class="comment">exponent and high-precision part of the mantissa go first. Since the low bits are</span></code></span>
<span class="codeline" id="line-137"><code><span class="comment">often zero, this can save encoding bytes. For instance, 17.0 is encoded in only</span></code></span>
<span class="codeline" id="line-138"><code><span class="comment">three bytes (FE 31 40).</span></code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code><span class="comment">Strings and slices of bytes are sent as an unsigned count followed by that many</span></code></span>
<span class="codeline" id="line-141"><code><span class="comment">uninterpreted bytes of the value.</span></code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code><span class="comment">All other slices and arrays are sent as an unsigned count followed by that many</span></code></span>
<span class="codeline" id="line-144"><code><span class="comment">elements using the standard gob encoding for their type, recursively.</span></code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code><span class="comment">Maps are sent as an unsigned count followed by that many key, element</span></code></span>
<span class="codeline" id="line-147"><code><span class="comment">pairs. Empty but non-nil maps are sent, so if the receiver has not allocated</span></code></span>
<span class="codeline" id="line-148"><code><span class="comment">one already, one will always be allocated on receipt unless the transmitted map</span></code></span>
<span class="codeline" id="line-149"><code><span class="comment">is nil and not at the top level.</span></code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code><span class="comment">In slices and arrays, as well as maps, all elements, even zero-valued elements,</span></code></span>
<span class="codeline" id="line-152"><code><span class="comment">are transmitted, even if all the elements are zero.</span></code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code><span class="comment">Structs are sent as a sequence of (field number, field value) pairs. The field</span></code></span>
<span class="codeline" id="line-155"><code><span class="comment">value is sent using the standard gob encoding for its type, recursively. If a</span></code></span>
<span class="codeline" id="line-156"><code><span class="comment">field has the zero value for its type (except for arrays; see above), it is omitted</span></code></span>
<span class="codeline" id="line-157"><code><span class="comment">from the transmission. The field number is defined by the type of the encoded</span></code></span>
<span class="codeline" id="line-158"><code><span class="comment">struct: the first field of the encoded type is field 0, the second is field 1,</span></code></span>
<span class="codeline" id="line-159"><code><span class="comment">etc. When encoding a value, the field numbers are delta encoded for efficiency</span></code></span>
<span class="codeline" id="line-160"><code><span class="comment">and the fields are always sent in order of increasing field number; the deltas are</span></code></span>
<span class="codeline" id="line-161"><code><span class="comment">therefore unsigned. The initialization for the delta encoding sets the field</span></code></span>
<span class="codeline" id="line-162"><code><span class="comment">number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned</span></code></span>
<span class="codeline" id="line-163"><code><span class="comment">delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been</span></code></span>
<span class="codeline" id="line-164"><code><span class="comment">sent a terminating mark denotes the end of the struct. That mark is a delta=0</span></code></span>
<span class="codeline" id="line-165"><code><span class="comment">value, which has representation (00).</span></code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code><span class="comment">Interface types are not checked for compatibility; all interface types are</span></code></span>
<span class="codeline" id="line-168"><code><span class="comment">treated, for transmission, as members of a single "interface" type, analogous to</span></code></span>
<span class="codeline" id="line-169"><code><span class="comment">int or []byte - in effect they're all treated as interface{}. Interface values</span></code></span>
<span class="codeline" id="line-170"><code><span class="comment">are transmitted as a string identifying the concrete type being sent (a name</span></code></span>
<span class="codeline" id="line-171"><code><span class="comment">that must be pre-defined by calling Register), followed by a byte count of the</span></code></span>
<span class="codeline" id="line-172"><code><span class="comment">length of the following data (so the value can be skipped if it cannot be</span></code></span>
<span class="codeline" id="line-173"><code><span class="comment">stored), followed by the usual encoding of concrete (dynamic) value stored in</span></code></span>
<span class="codeline" id="line-174"><code><span class="comment">the interface value. (A nil interface value is identified by the empty string</span></code></span>
<span class="codeline" id="line-175"><code><span class="comment">and transmits no value.) Upon receipt, the decoder verifies that the unpacked</span></code></span>
<span class="codeline" id="line-176"><code><span class="comment">concrete item satisfies the interface of the receiving variable.</span></code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code><span class="comment">If a value is passed to Encode and the type is not a struct (or pointer to struct,</span></code></span>
<span class="codeline" id="line-179"><code><span class="comment">etc.), for simplicity of processing it is represented as a struct of one field.</span></code></span>
<span class="codeline" id="line-180"><code><span class="comment">The only visible effect of this is to encode a zero byte after the value, just as</span></code></span>
<span class="codeline" id="line-181"><code><span class="comment">after the last field of an encoded struct, so that the decode algorithm knows when</span></code></span>
<span class="codeline" id="line-182"><code><span class="comment">the top-level value is complete.</span></code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code><span class="comment">The representation of types is described below. When a type is defined on a given</span></code></span>
<span class="codeline" id="line-185"><code><span class="comment">connection between an Encoder and Decoder, it is assigned a signed integer type</span></code></span>
<span class="codeline" id="line-186"><code><span class="comment">id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for</span></code></span>
<span class="codeline" id="line-187"><code><span class="comment">the type of v and all its elements and then it sends the pair (typeid, encoded-v)</span></code></span>
<span class="codeline" id="line-188"><code><span class="comment">where typeid is the type id of the encoded type of v and encoded-v is the gob</span></code></span>
<span class="codeline" id="line-189"><code><span class="comment">encoding of the value v.</span></code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code><span class="comment">To define a type, the encoder chooses an unused, positive type id and sends the</span></code></span>
<span class="codeline" id="line-192"><code><span class="comment">pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType</span></code></span>
<span class="codeline" id="line-193"><code><span class="comment">description, constructed from these types:</span></code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code><span class="comment">	type wireType struct {</span></code></span>
<span class="codeline" id="line-196"><code><span class="comment">		ArrayT           *ArrayType</span></code></span>
<span class="codeline" id="line-197"><code><span class="comment">		SliceT           *SliceType</span></code></span>
<span class="codeline" id="line-198"><code><span class="comment">		StructT          *StructType</span></code></span>
<span class="codeline" id="line-199"><code><span class="comment">		MapT             *MapType</span></code></span>
<span class="codeline" id="line-200"><code><span class="comment">		GobEncoderT      *gobEncoderType</span></code></span>
<span class="codeline" id="line-201"><code><span class="comment">		BinaryMarshalerT *gobEncoderType</span></code></span>
<span class="codeline" id="line-202"><code><span class="comment">		TextMarshalerT   *gobEncoderType</span></code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-205"><code><span class="comment">	type arrayType struct {</span></code></span>
<span class="codeline" id="line-206"><code><span class="comment">		CommonType</span></code></span>
<span class="codeline" id="line-207"><code><span class="comment">		Elem typeId</span></code></span>
<span class="codeline" id="line-208"><code><span class="comment">		Len  int</span></code></span>
<span class="codeline" id="line-209"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-210"><code><span class="comment">	type CommonType struct {</span></code></span>
<span class="codeline" id="line-211"><code><span class="comment">		Name string // the name of the struct type</span></code></span>
<span class="codeline" id="line-212"><code><span class="comment">		Id  int    // the id of the type, repeated so it's inside the type</span></code></span>
<span class="codeline" id="line-213"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-214"><code><span class="comment">	type sliceType struct {</span></code></span>
<span class="codeline" id="line-215"><code><span class="comment">		CommonType</span></code></span>
<span class="codeline" id="line-216"><code><span class="comment">		Elem typeId</span></code></span>
<span class="codeline" id="line-217"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-218"><code><span class="comment">	type structType struct {</span></code></span>
<span class="codeline" id="line-219"><code><span class="comment">		CommonType</span></code></span>
<span class="codeline" id="line-220"><code><span class="comment">		Field []*fieldType // the fields of the struct.</span></code></span>
<span class="codeline" id="line-221"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-222"><code><span class="comment">	type fieldType struct {</span></code></span>
<span class="codeline" id="line-223"><code><span class="comment">		Name string // the name of the field.</span></code></span>
<span class="codeline" id="line-224"><code><span class="comment">		Id   int    // the type id of the field, which must be already defined</span></code></span>
<span class="codeline" id="line-225"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-226"><code><span class="comment">	type mapType struct {</span></code></span>
<span class="codeline" id="line-227"><code><span class="comment">		CommonType</span></code></span>
<span class="codeline" id="line-228"><code><span class="comment">		Key  typeId</span></code></span>
<span class="codeline" id="line-229"><code><span class="comment">		Elem typeId</span></code></span>
<span class="codeline" id="line-230"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-231"><code><span class="comment">	type gobEncoderType struct {</span></code></span>
<span class="codeline" id="line-232"><code><span class="comment">		CommonType</span></code></span>
<span class="codeline" id="line-233"><code><span class="comment">	}</span></code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code><span class="comment">If there are nested type ids, the types for all inner type ids must be defined</span></code></span>
<span class="codeline" id="line-236"><code><span class="comment">before the top-level type id is used to describe an encoded-v.</span></code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code><span class="comment">For simplicity in setup, the connection is defined to understand these types a</span></code></span>
<span class="codeline" id="line-239"><code><span class="comment">priori, as well as the basic gob types int, uint, etc. Their ids are:</span></code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code><span class="comment">	bool        1</span></code></span>
<span class="codeline" id="line-242"><code><span class="comment">	int         2</span></code></span>
<span class="codeline" id="line-243"><code><span class="comment">	uint        3</span></code></span>
<span class="codeline" id="line-244"><code><span class="comment">	float       4</span></code></span>
<span class="codeline" id="line-245"><code><span class="comment">	[]byte      5</span></code></span>
<span class="codeline" id="line-246"><code><span class="comment">	string      6</span></code></span>
<span class="codeline" id="line-247"><code><span class="comment">	complex     7</span></code></span>
<span class="codeline" id="line-248"><code><span class="comment">	interface   8</span></code></span>
<span class="codeline" id="line-249"><code><span class="comment">	// gap for reserved ids.</span></code></span>
<span class="codeline" id="line-250"><code><span class="comment">	WireType    16</span></code></span>
<span class="codeline" id="line-251"><code><span class="comment">	ArrayType   17</span></code></span>
<span class="codeline" id="line-252"><code><span class="comment">	CommonType  18</span></code></span>
<span class="codeline" id="line-253"><code><span class="comment">	SliceType   19</span></code></span>
<span class="codeline" id="line-254"><code><span class="comment">	StructType  20</span></code></span>
<span class="codeline" id="line-255"><code><span class="comment">	FieldType   21</span></code></span>
<span class="codeline" id="line-256"><code><span class="comment">	// 22 is slice of fieldType.</span></code></span>
<span class="codeline" id="line-257"><code><span class="comment">	MapType     23</span></code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code><span class="comment">Finally, each message created by a call to Encode is preceded by an encoded</span></code></span>
<span class="codeline" id="line-260"><code><span class="comment">unsigned integer count of the number of bytes remaining in the message. After</span></code></span>
<span class="codeline" id="line-261"><code><span class="comment">the initial type name, interface values are wrapped the same way; in effect, the</span></code></span>
<span class="codeline" id="line-262"><code><span class="comment">interface value acts like a recursive invocation of Encode.</span></code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code><span class="comment">In summary, a gob stream looks like</span></code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code><span class="comment">	(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*</span></code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code><span class="comment">where * signifies zero or more repetitions and the type id of a value must</span></code></span>
<span class="codeline" id="line-269"><code><span class="comment">be predefined or be defined before the value in the stream.</span></code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code><span class="comment">Compatibility: Any future changes to the package will endeavor to maintain</span></code></span>
<span class="codeline" id="line-272"><code><span class="comment">compatibility with streams encoded using previous versions. That is, any released</span></code></span>
<span class="codeline" id="line-273"><code><span class="comment">version of this package should be able to decode data written with any previously</span></code></span>
<span class="codeline" id="line-274"><code><span class="comment">released version, subject to issues such as security fixes. See the Go compatibility</span></code></span>
<span class="codeline" id="line-275"><code><span class="comment">document for background: https://golang.org/doc/go1compat</span></code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code><span class="comment">See "Gobs of data" for a design discussion of the gob wire format:</span></code></span>
<span class="codeline" id="line-278"><code><span class="comment">https://blog.golang.org/gobs-of-data</span></code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code><span class="comment"># Security</span></code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code><span class="comment">This package is not designed to be hardened against adversarial inputs, and is</span></code></span>
<span class="codeline" id="line-283"><code><span class="comment">outside the scope of https://go.dev/security/policy. In particular, the Decoder</span></code></span>
<span class="codeline" id="line-284"><code><span class="comment">does only basic sanity checking on decoded input sizes, and its limits are not</span></code></span>
<span class="codeline" id="line-285"><code><span class="comment">configurable. Care should be taken when decoding gob data from untrusted</span></code></span>
<span class="codeline" id="line-286"><code><span class="comment">sources, which may consume significant resources.</span></code></span>
<span class="codeline" id="line-287"><code><span class="comment">*/</span></code></span></div><span class="codeline" id="line-288"><code><span class="keyword">package</span> gob</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code><span class="comment">/*</span></code></span>
<span class="codeline" id="line-291"><code><span class="comment">Grammar:</span></code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code><span class="comment">Tokens starting with a lower case letter are terminals; int(n)</span></code></span>
<span class="codeline" id="line-294"><code><span class="comment">and uint(n) represent the signed/unsigned encodings of the value n.</span></code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code><span class="comment">GobStream:</span></code></span>
<span class="codeline" id="line-297"><code><span class="comment">	DelimitedMessage*</span></code></span>
<span class="codeline" id="line-298"><code><span class="comment">DelimitedMessage:</span></code></span>
<span class="codeline" id="line-299"><code><span class="comment">	uint(lengthOfMessage) Message</span></code></span>
<span class="codeline" id="line-300"><code><span class="comment">Message:</span></code></span>
<span class="codeline" id="line-301"><code><span class="comment">	TypeSequence TypedValue</span></code></span>
<span class="codeline" id="line-302"><code><span class="comment">TypeSequence</span></code></span>
<span class="codeline" id="line-303"><code><span class="comment">	(TypeDefinition DelimitedTypeDefinition*)?</span></code></span>
<span class="codeline" id="line-304"><code><span class="comment">DelimitedTypeDefinition:</span></code></span>
<span class="codeline" id="line-305"><code><span class="comment">	uint(lengthOfTypeDefinition) TypeDefinition</span></code></span>
<span class="codeline" id="line-306"><code><span class="comment">TypedValue:</span></code></span>
<span class="codeline" id="line-307"><code><span class="comment">	int(typeId) Value</span></code></span>
<span class="codeline" id="line-308"><code><span class="comment">TypeDefinition:</span></code></span>
<span class="codeline" id="line-309"><code><span class="comment">	int(-typeId) encodingOfWireType</span></code></span>
<span class="codeline" id="line-310"><code><span class="comment">Value:</span></code></span>
<span class="codeline" id="line-311"><code><span class="comment">	SingletonValue | StructValue</span></code></span>
<span class="codeline" id="line-312"><code><span class="comment">SingletonValue:</span></code></span>
<span class="codeline" id="line-313"><code><span class="comment">	uint(0) FieldValue</span></code></span>
<span class="codeline" id="line-314"><code><span class="comment">FieldValue:</span></code></span>
<span class="codeline" id="line-315"><code><span class="comment">	builtinValue | ArrayValue | MapValue | SliceValue | StructValue | InterfaceValue</span></code></span>
<span class="codeline" id="line-316"><code><span class="comment">InterfaceValue:</span></code></span>
<span class="codeline" id="line-317"><code><span class="comment">	NilInterfaceValue | NonNilInterfaceValue</span></code></span>
<span class="codeline" id="line-318"><code><span class="comment">NilInterfaceValue:</span></code></span>
<span class="codeline" id="line-319"><code><span class="comment">	uint(0)</span></code></span>
<span class="codeline" id="line-320"><code><span class="comment">NonNilInterfaceValue:</span></code></span>
<span class="codeline" id="line-321"><code><span class="comment">	ConcreteTypeName TypeSequence InterfaceContents</span></code></span>
<span class="codeline" id="line-322"><code><span class="comment">ConcreteTypeName:</span></code></span>
<span class="codeline" id="line-323"><code><span class="comment">	uint(lengthOfName) [already read=n] name</span></code></span>
<span class="codeline" id="line-324"><code><span class="comment">InterfaceContents:</span></code></span>
<span class="codeline" id="line-325"><code><span class="comment">	int(concreteTypeId) DelimitedValue</span></code></span>
<span class="codeline" id="line-326"><code><span class="comment">DelimitedValue:</span></code></span>
<span class="codeline" id="line-327"><code><span class="comment">	uint(length) Value</span></code></span>
<span class="codeline" id="line-328"><code><span class="comment">ArrayValue:</span></code></span>
<span class="codeline" id="line-329"><code><span class="comment">	uint(n) FieldValue*n [n elements]</span></code></span>
<span class="codeline" id="line-330"><code><span class="comment">MapValue:</span></code></span>
<span class="codeline" id="line-331"><code><span class="comment">	uint(n) (FieldValue FieldValue)*n  [n (key, value) pairs]</span></code></span>
<span class="codeline" id="line-332"><code><span class="comment">SliceValue:</span></code></span>
<span class="codeline" id="line-333"><code><span class="comment">	uint(n) FieldValue*n [n elements]</span></code></span>
<span class="codeline" id="line-334"><code><span class="comment">StructValue:</span></code></span>
<span class="codeline" id="line-335"><code><span class="comment">	(uint(fieldDelta) FieldValue)*</span></code></span>
<span class="codeline" id="line-336"><code><span class="comment">*/</span></code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code><span class="comment">/*</span></code></span>
<span class="codeline" id="line-339"><code><span class="comment">For implementers and the curious, here is an encoded example. Given</span></code></span>
<span class="codeline" id="line-340"><code><span class="comment">	type Point struct {X, Y int}</span></code></span>
<span class="codeline" id="line-341"><code><span class="comment">and the value</span></code></span>
<span class="codeline" id="line-342"><code><span class="comment">	p := Point{22, 33}</span></code></span>
<span class="codeline" id="line-343"><code><span class="comment">the bytes transmitted that encode p will be:</span></code></span>
<span class="codeline" id="line-344"><code><span class="comment">	1f ff 81 03 01 01 05 50 6f 69 6e 74 01 ff 82 00</span></code></span>
<span class="codeline" id="line-345"><code><span class="comment">	01 02 01 01 58 01 04 00 01 01 59 01 04 00 00 00</span></code></span>
<span class="codeline" id="line-346"><code><span class="comment">	07 ff 82 01 2c 01 42 00</span></code></span>
<span class="codeline" id="line-347"><code><span class="comment">They are determined as follows.</span></code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code><span class="comment">Since this is the first transmission of type Point, the type descriptor</span></code></span>
<span class="codeline" id="line-350"><code><span class="comment">for Point itself must be sent before the value. This is the first type</span></code></span>
<span class="codeline" id="line-351"><code><span class="comment">we've sent on this Encoder, so it has type id 65 (0 through 64 are</span></code></span>
<span class="codeline" id="line-352"><code><span class="comment">reserved).</span></code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code><span class="comment">	1f	// This item (a type descriptor) is 31 bytes long.</span></code></span>
<span class="codeline" id="line-355"><code><span class="comment">	ff 81	// The negative of the id for the type we're defining, -65.</span></code></span>
<span class="codeline" id="line-356"><code><span class="comment">		// This is one byte (indicated by FF = -1) followed by</span></code></span>
<span class="codeline" id="line-357"><code><span class="comment">		// ^-65&lt;&lt;1 | 1. The low 1 bit signals to complement the</span></code></span>
<span class="codeline" id="line-358"><code><span class="comment">		// rest upon receipt.</span></code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code><span class="comment">	// Now we send a type descriptor, which is itself a struct (wireType).</span></code></span>
<span class="codeline" id="line-361"><code><span class="comment">	// The type of wireType itself is known (it's built in, as is the type of</span></code></span>
<span class="codeline" id="line-362"><code><span class="comment">	// all its components), so we just need to send a *value* of type wireType</span></code></span>
<span class="codeline" id="line-363"><code><span class="comment">	// that represents type "Point".</span></code></span>
<span class="codeline" id="line-364"><code><span class="comment">	// Here starts the encoding of that value.</span></code></span>
<span class="codeline" id="line-365"><code><span class="comment">	// Set the field number implicitly to -1; this is done at the beginning</span></code></span>
<span class="codeline" id="line-366"><code><span class="comment">	// of every struct, including nested structs.</span></code></span>
<span class="codeline" id="line-367"><code><span class="comment">	03	// Add 3 to field number; now 2 (wireType.structType; this is a struct).</span></code></span>
<span class="codeline" id="line-368"><code><span class="comment">		// structType starts with an embedded CommonType, which appears</span></code></span>
<span class="codeline" id="line-369"><code><span class="comment">		// as a regular structure here too.</span></code></span>
<span class="codeline" id="line-370"><code><span class="comment">	01	// add 1 to field number (now 0); start of embedded CommonType.</span></code></span>
<span class="codeline" id="line-371"><code><span class="comment">	01	// add 1 to field number (now 0, the name of the type)</span></code></span>
<span class="codeline" id="line-372"><code><span class="comment">	05	// string is (unsigned) 5 bytes long</span></code></span>
<span class="codeline" id="line-373"><code><span class="comment">	50 6f 69 6e 74	// wireType.structType.CommonType.name = "Point"</span></code></span>
<span class="codeline" id="line-374"><code><span class="comment">	01	// add 1 to field number (now 1, the id of the type)</span></code></span>
<span class="codeline" id="line-375"><code><span class="comment">	ff 82	// wireType.structType.CommonType._id = 65</span></code></span>
<span class="codeline" id="line-376"><code><span class="comment">	00	// end of embedded wiretype.structType.CommonType struct</span></code></span>
<span class="codeline" id="line-377"><code><span class="comment">	01	// add 1 to field number (now 1, the field array in wireType.structType)</span></code></span>
<span class="codeline" id="line-378"><code><span class="comment">	02	// There are two fields in the type (len(structType.field))</span></code></span>
<span class="codeline" id="line-379"><code><span class="comment">	01	// Start of first field structure; add 1 to get field number 0: field[0].name</span></code></span>
<span class="codeline" id="line-380"><code><span class="comment">	01	// 1 byte</span></code></span>
<span class="codeline" id="line-381"><code><span class="comment">	58	// structType.field[0].name = "X"</span></code></span>
<span class="codeline" id="line-382"><code><span class="comment">	01	// Add 1 to get field number 1: field[0].id</span></code></span>
<span class="codeline" id="line-383"><code><span class="comment">	04	// structType.field[0].typeId is 2 (signed int).</span></code></span>
<span class="codeline" id="line-384"><code><span class="comment">	00	// End of structType.field[0]; start structType.field[1]; set field number to -1.</span></code></span>
<span class="codeline" id="line-385"><code><span class="comment">	01	// Add 1 to get field number 0: field[1].name</span></code></span>
<span class="codeline" id="line-386"><code><span class="comment">	01	// 1 byte</span></code></span>
<span class="codeline" id="line-387"><code><span class="comment">	59	// structType.field[1].name = "Y"</span></code></span>
<span class="codeline" id="line-388"><code><span class="comment">	01	// Add 1 to get field number 1: field[1].id</span></code></span>
<span class="codeline" id="line-389"><code><span class="comment">	04	// struct.Type.field[1].typeId is 2 (signed int).</span></code></span>
<span class="codeline" id="line-390"><code><span class="comment">	00	// End of structType.field[1]; end of structType.field.</span></code></span>
<span class="codeline" id="line-391"><code><span class="comment">	00	// end of wireType.structType structure</span></code></span>
<span class="codeline" id="line-392"><code><span class="comment">	00	// end of wireType structure</span></code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code><span class="comment">Now we can send the Point value. Again the field number resets to -1:</span></code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code><span class="comment">	07	// this value is 7 bytes long</span></code></span>
<span class="codeline" id="line-397"><code><span class="comment">	ff 82	// the type number, 65 (1 byte (-FF) followed by 65&lt;&lt;1)</span></code></span>
<span class="codeline" id="line-398"><code><span class="comment">	01	// add one to field number, yielding field 0</span></code></span>
<span class="codeline" id="line-399"><code><span class="comment">	2c	// encoding of signed "22" (0x2c = 44 = 22&lt;&lt;1); Point.x = 22</span></code></span>
<span class="codeline" id="line-400"><code><span class="comment">	01	// add one to field number, yielding field 1</span></code></span>
<span class="codeline" id="line-401"><code><span class="comment">	42	// encoding of signed "33" (0x42 = 66 = 33&lt;&lt;1); Point.y = 33</span></code></span>
<span class="codeline" id="line-402"><code><span class="comment">	00	// end of structure</span></code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code><span class="comment">The type encoding is long and fairly intricate but we send it only once.</span></code></span>
<span class="codeline" id="line-405"><code><span class="comment">If p is transmitted a second time, the type is already known so the</span></code></span>
<span class="codeline" id="line-406"><code><span class="comment">output will be just:</span></code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code><span class="comment">	07 ff 82 01 2c 01 42 00</span></code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code><span class="comment">A single non-struct value at top level is transmitted like a field with</span></code></span>
<span class="codeline" id="line-411"><code><span class="comment">delta tag 0. For instance, a signed integer with value 3 presented as</span></code></span>
<span class="codeline" id="line-412"><code><span class="comment">the argument to Encode will emit:</span></code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code><span class="comment">	03 04 00 06</span></code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code><span class="comment">Which represents:</span></code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code><span class="comment">	03	// this value is 3 bytes long</span></code></span>
<span class="codeline" id="line-419"><code><span class="comment">	04	// the type number, 2, represents an integer</span></code></span>
<span class="codeline" id="line-420"><code><span class="comment">	00	// tag delta 0</span></code></span>
<span class="codeline" id="line-421"><code><span class="comment">	06	// value 3</span></code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code><span class="comment">*/</span></code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>