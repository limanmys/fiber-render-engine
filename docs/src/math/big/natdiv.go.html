<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: natdiv.go in package math/big</title>
<link href="../../../css/light-v0.5.7.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.5.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	natdiv.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/math/big.html">math/big</a>
</code></pre>
<style>input[type=radio] {display: none;}
input[id=r0]:checked ~pre label[for=r0],
input[id=r1]:checked ~pre label[for=r1],
input[id=r2]:checked ~pre label[for=r2],
input[id=r3]:checked ~pre label[for=r3],
input[id=r4]:checked ~pre label[for=r4],
input[id=r5]:checked ~pre label[for=r5],
input[id=r6]:checked ~pre label[for=r6],
input[id=r7]:checked ~pre label[for=r7],
input[id=r8]:checked ~pre label[for=r8],
input[id=r9]:checked ~pre label[for=r9],
input[id=r10]:checked ~pre label[for=r10],
input[id=r11]:checked ~pre label[for=r11],
input[id=r12]:checked ~pre label[for=r12],
input[id=r13]:checked ~pre label[for=r13],
input[id=r14]:checked ~pre label[for=r14],
input[id=r15]:checked ~pre label[for=r15],
input[id=r16]:checked ~pre label[for=r16],
input[id=r17]:checked ~pre label[for=r17],
input[id=r18]:checked ~pre label[for=r18],
input[id=r19]:checked ~pre label[for=r19],
input[id=r20]:checked ~pre label[for=r20],
input[id=r21]:checked ~pre label[for=r21],
input[id=r22]:checked ~pre label[for=r22],
input[id=r23]:checked ~pre label[for=r23],
input[id=r24]:checked ~pre label[for=r24],
input[id=r25]:checked ~pre label[for=r25],
input[id=r26]:checked ~pre label[for=r26],
input[id=r27]:checked ~pre label[for=r27],
input[id=r28]:checked ~pre label[for=r28],
input[id=r29]:checked ~pre label[for=r29],
input[id=r30]:checked ~pre label[for=r30],
input[id=r31]:checked ~pre label[for=r31],
input[id=r32]:checked ~pre label[for=r32],
input[id=r33]:checked ~pre label[for=r33],
input[id=r34]:checked ~pre label[for=r34],
input[id=r35]:checked ~pre label[for=r35],
input[id=r36]:checked ~pre label[for=r36],
input[id=r37]:checked ~pre label[for=r37],
input[id=r38]:checked ~pre label[for=r38],
input[id=r39]:checked ~pre label[for=r39],
input[id=r40]:checked ~pre label[for=r40],
input[id=r41]:checked ~pre label[for=r41],
input[id=r42]:checked ~pre label[for=r42],
input[id=r43]:checked ~pre label[for=r43],
input[id=r44]:checked ~pre label[for=r44],
input[id=r45]:checked ~pre label[for=r45],
input[id=r46]:checked ~pre label[for=r46],
input[id=r47]:checked ~pre label[for=r47],
input[id=r48]:checked ~pre label[for=r48],
input[id=r49]:checked ~pre label[for=r49],
input[id=r50]:checked ~pre label[for=r50],
input[id=r51]:checked ~pre label[for=r51],
input[id=r52]:checked ~pre label[for=r52],
input[id=r53]:checked ~pre label[for=r53],
input[id=r54]:checked ~pre label[for=r54],
input[id=r55]:checked ~pre label[for=r55],
input[id=r56]:checked ~pre label[for=r56],
input[id=r57]:checked ~pre label[for=r57],
input[id=r58]:checked ~pre label[for=r58],
input[id=r59]:checked ~pre label[for=r59],
input[id=r60]:checked ~pre label[for=r60],
input[id=r61]:checked ~pre label[for=r61],
input[id=r62]:checked ~pre label[for=r62],
input[id=r63]:checked ~pre label[for=r63],
input[id=r64]:checked ~pre label[for=r64],
input[id=r65]:checked ~pre label[for=r65],
input[id=r66]:checked ~pre label[for=r66],
input[id=r67]:checked ~pre label[for=r67],
input[id=r68]:checked ~pre label[for=r68],
input[id=r69]:checked ~pre label[for=r69],
input[id=r70]:checked ~pre label[for=r70],
input[id=r71]:checked ~pre label[for=r71],
input[id=r72]:checked ~pre label[for=r72],
input[id=r73]:checked ~pre label[for=r73],
input[id=r74]:checked ~pre label[for=r74],
input[id=r75]:checked ~pre label[for=r75],
input[id=r76]:checked ~pre label[for=r76],
input[id=r77]:checked ~pre label[for=r77],
input[id=r78]:checked ~pre label[for=r78],
input[id=r79]:checked ~pre label[for=r79],
input[id=r80]:checked ~pre label[for=r80],
input[id=r81]:checked ~pre label[for=r81],
input[id=r82]:checked ~pre label[for=r82],
input[id=r83]:checked ~pre label[for=r83],
input[id=r84]:checked ~pre label[for=r84],
input[id=r85]:checked ~pre label[for=r85],
input[id=r86]:checked ~pre label[for=r86],
input[id=r87]:checked ~pre label[for=r87],
input[id=r88]:checked ~pre label[for=r88],
input[id=r89]:checked ~pre label[for=r89],
input[id=r90]:checked ~pre label[for=r90],
input[id=r91]:checked ~pre label[for=r91],
input[id=r92]:checked ~pre label[for=r92],
input[id=r93]:checked ~pre label[for=r93],
input[id=r94]:checked ~pre label[for=r94],
input[id=r95]:checked ~pre label[for=r95],
input[id=r96]:checked ~pre label[for=r96],
input[id=r97]:checked ~pre label[for=r97],
input[id=r98]:checked ~pre label[for=r98],
input[id=r99]:checked ~pre label[for=r99],
input[id=r100]:checked ~pre label[for=r100],
input[id=r101]:checked ~pre label[for=r101],
input[id=r102]:checked ~pre label[for=r102],
input[id=r103]:checked ~pre label[for=r103]
{background: #226; color: #ff8;}
input[id=i0]:checked ~pre .i0
{background: brown; color: #eed;}
</style><input id="r0" type="radio" name="g"/>
<input id="r1" type="radio" name="g"/>
<input id="r2" type="radio" name="g"/>
<input id="r3" type="radio" name="g"/>
<input id="r4" type="radio" name="g"/>
<input id="r5" type="radio" name="g"/>
<input id="r6" type="radio" name="g"/>
<input id="r7" type="radio" name="g"/>
<input id="r8" type="radio" name="g"/>
<input id="r9" type="radio" name="g"/>
<input id="r10" type="radio" name="g"/>
<input id="r11" type="radio" name="g"/>
<input id="r12" type="radio" name="g"/>
<input id="r13" type="radio" name="g"/>
<input id="r14" type="radio" name="g"/>
<input id="r15" type="radio" name="g"/>
<input id="r16" type="radio" name="g"/>
<input id="r17" type="radio" name="g"/>
<input id="r18" type="radio" name="g"/>
<input id="r19" type="radio" name="g"/>
<input id="r20" type="radio" name="g"/>
<input id="r21" type="radio" name="g"/>
<input id="r22" type="radio" name="g"/>
<input id="r23" type="radio" name="g"/>
<input id="r24" type="radio" name="g"/>
<input id="r25" type="radio" name="g"/>
<input id="r26" type="radio" name="g"/>
<input id="r27" type="radio" name="g"/>
<input id="r28" type="radio" name="g"/>
<input id="r29" type="radio" name="g"/>
<input id="r30" type="radio" name="g"/>
<input id="r31" type="radio" name="g"/>
<input id="r32" type="radio" name="g"/>
<input id="r33" type="radio" name="g"/>
<input id="r34" type="radio" name="g"/>
<input id="r35" type="radio" name="g"/>
<input id="r36" type="radio" name="g"/>
<input id="r37" type="radio" name="g"/>
<input id="r38" type="radio" name="g"/>
<input id="r39" type="radio" name="g"/>
<input id="r40" type="radio" name="g"/>
<input id="r41" type="radio" name="g"/>
<input id="r42" type="radio" name="g"/>
<input id="r43" type="radio" name="g"/>
<input id="r44" type="radio" name="g"/>
<input id="r45" type="radio" name="g"/>
<input id="r46" type="radio" name="g"/>
<input id="r47" type="radio" name="g"/>
<input id="r48" type="radio" name="g"/>
<input id="r49" type="radio" name="g"/>
<input id="r50" type="radio" name="g"/>
<input id="r51" type="radio" name="g"/>
<input id="r52" type="radio" name="g"/>
<input id="r53" type="radio" name="g"/>
<input id="r54" type="radio" name="g"/>
<input id="r55" type="radio" name="g"/>
<input id="r56" type="radio" name="g"/>
<input id="r57" type="radio" name="g"/>
<input id="r58" type="radio" name="g"/>
<input id="r59" type="radio" name="g"/>
<input id="r60" type="radio" name="g"/>
<input id="r61" type="radio" name="g"/>
<input id="r62" type="radio" name="g"/>
<input id="r63" type="radio" name="g"/>
<input id="r64" type="radio" name="g"/>
<input id="r65" type="radio" name="g"/>
<input id="r66" type="radio" name="g"/>
<input id="r67" type="radio" name="g"/>
<input id="r68" type="radio" name="g"/>
<input id="r69" type="radio" name="g"/>
<input id="r70" type="radio" name="g"/>
<input id="r71" type="radio" name="g"/>
<input id="r72" type="radio" name="g"/>
<input id="r73" type="radio" name="g"/>
<input id="r74" type="radio" name="g"/>
<input id="r75" type="radio" name="g"/>
<input id="r76" type="radio" name="g"/>
<input id="r77" type="radio" name="g"/>
<input id="r78" type="radio" name="g"/>
<input id="r79" type="radio" name="g"/>
<input id="r80" type="radio" name="g"/>
<input id="r81" type="radio" name="g"/>
<input id="r82" type="radio" name="g"/>
<input id="r83" type="radio" name="g"/>
<input id="r84" type="radio" name="g"/>
<input id="r85" type="radio" name="g"/>
<input id="r86" type="radio" name="g"/>
<input id="r87" type="radio" name="g"/>
<input id="r88" type="radio" name="g"/>
<input id="r89" type="radio" name="g"/>
<input id="r90" type="radio" name="g"/>
<input id="r91" type="radio" name="g"/>
<input id="r92" type="radio" name="g"/>
<input id="r93" type="radio" name="g"/>
<input id="r94" type="radio" name="g"/>
<input id="r95" type="radio" name="g"/>
<input id="r96" type="radio" name="g"/>
<input id="r97" type="radio" name="g"/>
<input id="r98" type="radio" name="g"/>
<input id="r99" type="radio" name="g"/>
<input id="r100" type="radio" name="g"/>
<input id="r101" type="radio" name="g"/>
<input id="r102" type="radio" name="g"/>
<input id="r103" type="radio" name="g"/>
<input id="i0" type="radio" name="i"/>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></code></span>
<span class="codeline" id="line-2"><code><span class="comment">// Use of this source code is governed by a BSD-style</span></code></span>
<span class="codeline" id="line-3"><code><span class="comment">// license that can be found in the LICENSE file.</span></code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code><span class="comment">/*</span></code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code><span class="comment">Multi-precision division. Here be dragons.</span></code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code><span class="comment">Given u and v, where u is n+m digits, and v is n digits (with no leading zeros),</span></code></span>
<span class="codeline" id="line-10"><code><span class="comment">the goal is to return quo, rem such that u = quo*v + rem, where 0 ≤ rem &lt; v.</span></code></span>
<span class="codeline" id="line-11"><code><span class="comment">That is, quo = ⌊u/v⌋ where ⌊x⌋ denotes the floor (truncation to integer) of x,</span></code></span>
<span class="codeline" id="line-12"><code><span class="comment">and rem = u - quo·v.</span></code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code><span class="comment">Long Division</span></code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code><span class="comment">Division in a computer proceeds the same as long division in elementary school,</span></code></span>
<span class="codeline" id="line-18"><code><span class="comment">but computers are not as good as schoolchildren at following vague directions,</span></code></span>
<span class="codeline" id="line-19"><code><span class="comment">so we have to be much more precise about the actual steps and what can happen.</span></code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code><span class="comment">We work from most to least significant digit of the quotient, doing:</span></code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code><span class="comment"> • Guess a digit q, the number of v to subtract from the current</span></code></span>
<span class="codeline" id="line-24"><code><span class="comment">   section of u to zero out the topmost digit.</span></code></span>
<span class="codeline" id="line-25"><code><span class="comment"> • Check the guess by multiplying q·v and comparing it against</span></code></span>
<span class="codeline" id="line-26"><code><span class="comment">   the current section of u, adjusting the guess as needed.</span></code></span>
<span class="codeline" id="line-27"><code><span class="comment"> • Subtract q·v from the current section of u.</span></code></span>
<span class="codeline" id="line-28"><code><span class="comment"> • Add q to the corresponding section of the result quo.</span></code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code><span class="comment">When all digits have been processed, the final remainder is left in u</span></code></span>
<span class="codeline" id="line-31"><code><span class="comment">and returned as rem.</span></code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code><span class="comment">For example, here is a sketch of dividing 5 digits by 3 digits (n=3, m=2).</span></code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code><span class="comment">	                 q₂ q₁ q₀</span></code></span>
<span class="codeline" id="line-36"><code><span class="comment">	         _________________</span></code></span>
<span class="codeline" id="line-37"><code><span class="comment">	v₂ v₁ v₀ ) u₄ u₃ u₂ u₁ u₀</span></code></span>
<span class="codeline" id="line-38"><code><span class="comment">	           ↓  ↓  ↓  |  |</span></code></span>
<span class="codeline" id="line-39"><code><span class="comment">	          [u₄ u₃ u₂]|  |</span></code></span>
<span class="codeline" id="line-40"><code><span class="comment">	        - [  q₂·v  ]|  |</span></code></span>
<span class="codeline" id="line-41"><code><span class="comment">	        ----------- ↓  |</span></code></span>
<span class="codeline" id="line-42"><code><span class="comment">	          [  rem  | u₁]|</span></code></span>
<span class="codeline" id="line-43"><code><span class="comment">	        - [    q₁·v   ]|</span></code></span>
<span class="codeline" id="line-44"><code><span class="comment">	           ----------- ↓</span></code></span>
<span class="codeline" id="line-45"><code><span class="comment">	             [  rem  | u₀]</span></code></span>
<span class="codeline" id="line-46"><code><span class="comment">	           - [    q₀·v   ]</span></code></span>
<span class="codeline" id="line-47"><code><span class="comment">	              ------------</span></code></span>
<span class="codeline" id="line-48"><code><span class="comment">	                [  rem   ]</span></code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code><span class="comment">Instead of creating new storage for the remainders and copying digits from u</span></code></span>
<span class="codeline" id="line-51"><code><span class="comment">as indicated by the arrows, we use u's storage directly as both the source</span></code></span>
<span class="codeline" id="line-52"><code><span class="comment">and destination of the subtractions, so that the remainders overwrite</span></code></span>
<span class="codeline" id="line-53"><code><span class="comment">successive overlapping sections of u as the division proceeds, using a slice</span></code></span>
<span class="codeline" id="line-54"><code><span class="comment">of u to identify the current section. This avoids all the copying as well as</span></code></span>
<span class="codeline" id="line-55"><code><span class="comment">shifting of remainders.</span></code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code><span class="comment">Division of u with n+m digits by v with n digits (in base B) can in general</span></code></span>
<span class="codeline" id="line-58"><code><span class="comment">produce at most m+1 digits, because:</span></code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code><span class="comment">  • u &lt; B^(n+m)               [B^(n+m) has n+m+1 digits]</span></code></span>
<span class="codeline" id="line-61"><code><span class="comment">  • v ≥ B^(n-1)               [B^(n-1) is the smallest n-digit number]</span></code></span>
<span class="codeline" id="line-62"><code><span class="comment">  • u/v &lt; B^(n+m) / B^(n-1)   [divide bounds for u, v]</span></code></span>
<span class="codeline" id="line-63"><code><span class="comment">  • u/v &lt; B^(m+1)             [simplify]</span></code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code><span class="comment">The first step is special: it takes the top n digits of u and divides them by</span></code></span>
<span class="codeline" id="line-66"><code><span class="comment">the n digits of v, producing the first quotient digit and an n-digit remainder.</span></code></span>
<span class="codeline" id="line-67"><code><span class="comment">In the example, q₂ = ⌊u₄u₃u₂ / v⌋.</span></code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code><span class="comment">The first step divides n digits by n digits to ensure that it produces only a</span></code></span>
<span class="codeline" id="line-70"><code><span class="comment">single digit.</span></code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code><span class="comment">Each subsequent step appends the next digit from u to the remainder and divides</span></code></span>
<span class="codeline" id="line-73"><code><span class="comment">those n+1 digits by the n digits of v, producing another quotient digit and a</span></code></span>
<span class="codeline" id="line-74"><code><span class="comment">new n-digit remainder.</span></code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code><span class="comment">Subsequent steps divide n+1 digits by n digits, an operation that in general</span></code></span>
<span class="codeline" id="line-77"><code><span class="comment">might produce two digits. However, as used in the algorithm, that division is</span></code></span>
<span class="codeline" id="line-78"><code><span class="comment">guaranteed to produce only a single digit. The dividend is of the form</span></code></span>
<span class="codeline" id="line-79"><code><span class="comment">rem·B + d, where rem is a remainder from the previous step and d is a single</span></code></span>
<span class="codeline" id="line-80"><code><span class="comment">digit, so:</span></code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code><span class="comment"> • rem ≤ v - 1                 [rem is a remainder from dividing by v]</span></code></span>
<span class="codeline" id="line-83"><code><span class="comment"> • rem·B ≤ v·B - B             [multiply by B]</span></code></span>
<span class="codeline" id="line-84"><code><span class="comment"> • d ≤ B - 1                   [d is a single digit]</span></code></span>
<span class="codeline" id="line-85"><code><span class="comment"> • rem·B + d ≤ v·B - 1         [add]</span></code></span>
<span class="codeline" id="line-86"><code><span class="comment"> • rem·B + d &lt; v·B             [change ≤ to &lt;]</span></code></span>
<span class="codeline" id="line-87"><code><span class="comment"> • (rem·B + d)/v &lt; B           [divide by v]</span></code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code><span class="comment">Guess and Check</span></code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code><span class="comment">At each step we need to divide n+1 digits by n digits, but this is for the</span></code></span>
<span class="codeline" id="line-93"><code><span class="comment">implementation of division by n digits, so we can't just invoke a division</span></code></span>
<span class="codeline" id="line-94"><code><span class="comment">routine: we _are_ the division routine. Instead, we guess at the answer and</span></code></span>
<span class="codeline" id="line-95"><code><span class="comment">then check it using multiplication. If the guess is wrong, we correct it.</span></code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code><span class="comment">How can this guessing possibly be efficient? It turns out that the following</span></code></span>
<span class="codeline" id="line-98"><code><span class="comment">statement (let's call it the Good Guess Guarantee) is true.</span></code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code><span class="comment">If</span></code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code><span class="comment"> • q = ⌊u/v⌋ where u is n+1 digits and v is n digits,</span></code></span>
<span class="codeline" id="line-103"><code><span class="comment"> • q &lt; B, and</span></code></span>
<span class="codeline" id="line-104"><code><span class="comment"> • the topmost digit of v = vₙ₋₁ ≥ B/2,</span></code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code><span class="comment">then q̂ = ⌊uₙuₙ₋₁ / vₙ₋₁⌋ satisfies q ≤ q̂ ≤ q+2. (Proof below.)</span></code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code><span class="comment">That is, if we know the answer has only a single digit and we guess an answer</span></code></span>
<span class="codeline" id="line-109"><code><span class="comment">by ignoring the bottom n-1 digits of u and v, using a 2-by-1-digit division,</span></code></span>
<span class="codeline" id="line-110"><code><span class="comment">then that guess is at least as large as the correct answer. It is also not</span></code></span>
<span class="codeline" id="line-111"><code><span class="comment">too much larger: it is off by at most two from the correct answer.</span></code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code><span class="comment">Note that in the first step of the overall division, which is an n-by-n-digit</span></code></span>
<span class="codeline" id="line-114"><code><span class="comment">division, the 2-by-1 guess uses an implicit uₙ = 0.</span></code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code><span class="comment">Note that using a 2-by-1-digit division here does not mean calling ourselves</span></code></span>
<span class="codeline" id="line-117"><code><span class="comment">recursively. Instead, we use an efficient direct hardware implementation of</span></code></span>
<span class="codeline" id="line-118"><code><span class="comment">that operation.</span></code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code><span class="comment">Note that because q is u/v rounded down, q·v must not exceed u: u ≥ q·v.</span></code></span>
<span class="codeline" id="line-121"><code><span class="comment">If a guess q̂ is too big, it will not satisfy this test. Viewed a different way,</span></code></span>
<span class="codeline" id="line-122"><code><span class="comment">the remainder r̂ for a given q̂ is u - q̂·v, which must be positive. If it is</span></code></span>
<span class="codeline" id="line-123"><code><span class="comment">negative, then the guess q̂ is too big.</span></code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code><span class="comment">This gives us a way to compute q. First compute q̂ with 2-by-1-digit division.</span></code></span>
<span class="codeline" id="line-126"><code><span class="comment">Then, while u &lt; q̂·v, decrement q̂; this loop executes at most twice, because</span></code></span>
<span class="codeline" id="line-127"><code><span class="comment">q̂ ≤ q+2.</span></code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code><span class="comment">Scaling Inputs</span></code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code><span class="comment">The Good Guess Guarantee requires that the top digit of v (vₙ₋₁) be at least B/2.</span></code></span>
<span class="codeline" id="line-133"><code><span class="comment">For example in base 10, ⌊172/19⌋ = 9, but ⌊18/1⌋ = 18: the guess is wildly off</span></code></span>
<span class="codeline" id="line-134"><code><span class="comment">because the first digit 1 is smaller than B/2 = 5.</span></code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code><span class="comment">We can ensure that v has a large top digit by multiplying both u and v by the</span></code></span>
<span class="codeline" id="line-137"><code><span class="comment">right amount. Continuing the example, if we multiply both 172 and 19 by 3, we</span></code></span>
<span class="codeline" id="line-138"><code><span class="comment">now have ⌊516/57⌋, the leading digit of v is now ≥ 5, and sure enough</span></code></span>
<span class="codeline" id="line-139"><code><span class="comment">⌊51/5⌋ = 10 is much closer to the correct answer 9. It would be easier here</span></code></span>
<span class="codeline" id="line-140"><code><span class="comment">to multiply by 4, because that can be done with a shift. Specifically, we can</span></code></span>
<span class="codeline" id="line-141"><code><span class="comment">always count the number of leading zeros i in the first digit of v and then</span></code></span>
<span class="codeline" id="line-142"><code><span class="comment">shift both u and v left by i bits.</span></code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code><span class="comment">Having scaled u and v, the value ⌊u/v⌋ is unchanged, but the remainder will</span></code></span>
<span class="codeline" id="line-145"><code><span class="comment">be scaled: 172 mod 19 is 1, but 516 mod 57 is 3. We have to divide the remainder</span></code></span>
<span class="codeline" id="line-146"><code><span class="comment">by the scaling factor (shifting right i bits) when we finish.</span></code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code><span class="comment">Note that these shifts happen before and after the entire division algorithm,</span></code></span>
<span class="codeline" id="line-149"><code><span class="comment">not at each step in the per-digit iteration.</span></code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code><span class="comment">Note the effect of scaling inputs on the size of the possible quotient.</span></code></span>
<span class="codeline" id="line-152"><code><span class="comment">In the scaled u/v, u can gain a digit from scaling; v never does, because we</span></code></span>
<span class="codeline" id="line-153"><code><span class="comment">pick the scaling factor to make v's top digit larger but without overflowing.</span></code></span>
<span class="codeline" id="line-154"><code><span class="comment">If u and v have n+m and n digits after scaling, then:</span></code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code><span class="comment">  • u &lt; B^(n+m)               [B^(n+m) has n+m+1 digits]</span></code></span>
<span class="codeline" id="line-157"><code><span class="comment">  • v ≥ B^n / 2               [vₙ₋₁ ≥ B/2, so vₙ₋₁·B^(n-1) ≥ B^n/2]</span></code></span>
<span class="codeline" id="line-158"><code><span class="comment">  • u/v &lt; B^(n+m) / (B^n / 2) [divide bounds for u, v]</span></code></span>
<span class="codeline" id="line-159"><code><span class="comment">  • u/v &lt; 2 B^m               [simplify]</span></code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code><span class="comment">The quotient can still have m+1 significant digits, but if so the top digit</span></code></span>
<span class="codeline" id="line-162"><code><span class="comment">must be a 1. This provides a different way to handle the first digit of the</span></code></span>
<span class="codeline" id="line-163"><code><span class="comment">result: compare the top n digits of u against v and fill in either a 0 or a 1.</span></code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code><span class="comment">Refining Guesses</span></code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code><span class="comment">Before we check whether u &lt; q̂·v, we can adjust our guess to change it from</span></code></span>
<span class="codeline" id="line-169"><code><span class="comment">q̂ = ⌊uₙuₙ₋₁ / vₙ₋₁⌋ into the refined guess ⌊uₙuₙ₋₁uₙ₋₂ / vₙ₋₁vₙ₋₂⌋.</span></code></span>
<span class="codeline" id="line-170"><code><span class="comment">Although not mentioned above, the Good Guess Guarantee also promises that this</span></code></span>
<span class="codeline" id="line-171"><code><span class="comment">3-by-2-digit division guess is more precise and at most one away from the real</span></code></span>
<span class="codeline" id="line-172"><code><span class="comment">answer q. The improvement from the 2-by-1 to the 3-by-2 guess can also be done</span></code></span>
<span class="codeline" id="line-173"><code><span class="comment">without n-digit math.</span></code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code><span class="comment">If we have a guess q̂ = ⌊uₙuₙ₋₁ / vₙ₋₁⌋ and we want to see if it also equal to</span></code></span>
<span class="codeline" id="line-176"><code><span class="comment">⌊uₙuₙ₋₁uₙ₋₂ / vₙ₋₁vₙ₋₂⌋, we can use the same check we would for the full division:</span></code></span>
<span class="codeline" id="line-177"><code><span class="comment">if uₙuₙ₋₁uₙ₋₂ &lt; q̂·vₙ₋₁vₙ₋₂, then the guess is too large and should be reduced.</span></code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code><span class="comment">Checking uₙuₙ₋₁uₙ₋₂ &lt; q̂·vₙ₋₁vₙ₋₂ is the same as uₙuₙ₋₁uₙ₋₂ - q̂·vₙ₋₁vₙ₋₂ &lt; 0,</span></code></span>
<span class="codeline" id="line-180"><code><span class="comment">and</span></code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code><span class="comment">	uₙuₙ₋₁uₙ₋₂ - q̂·vₙ₋₁vₙ₋₂ = (uₙuₙ₋₁·B + uₙ₋₂) - q̂·(vₙ₋₁·B + vₙ₋₂)</span></code></span>
<span class="codeline" id="line-183"><code><span class="comment">	                          [splitting off the bottom digit]</span></code></span>
<span class="codeline" id="line-184"><code><span class="comment">	                      = (uₙuₙ₋₁ - q̂·vₙ₋₁)·B + uₙ₋₂ - q̂·vₙ₋₂</span></code></span>
<span class="codeline" id="line-185"><code><span class="comment">	                          [regrouping]</span></code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code><span class="comment">The expression (uₙuₙ₋₁ - q̂·vₙ₋₁) is the remainder of uₙuₙ₋₁ / vₙ₋₁.</span></code></span>
<span class="codeline" id="line-188"><code><span class="comment">If the initial guess returns both q̂ and its remainder r̂, then checking</span></code></span>
<span class="codeline" id="line-189"><code><span class="comment">whether uₙuₙ₋₁uₙ₋₂ &lt; q̂·vₙ₋₁vₙ₋₂ is the same as checking r̂·B + uₙ₋₂ &lt; q̂·vₙ₋₂.</span></code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code><span class="comment">If we find that r̂·B + uₙ₋₂ &lt; q̂·vₙ₋₂, then we can adjust the guess by</span></code></span>
<span class="codeline" id="line-192"><code><span class="comment">decrementing q̂ and adding vₙ₋₁ to r̂. We repeat until r̂·B + uₙ₋₂ ≥ q̂·vₙ₋₂.</span></code></span>
<span class="codeline" id="line-193"><code><span class="comment">(As before, this fixup is only needed at most twice.)</span></code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code><span class="comment">Now that q̂ = ⌊uₙuₙ₋₁uₙ₋₂ / vₙ₋₁vₙ₋₂⌋, as mentioned above it is at most one</span></code></span>
<span class="codeline" id="line-196"><code><span class="comment">away from the correct q, and we've avoided doing any n-digit math.</span></code></span>
<span class="codeline" id="line-197"><code><span class="comment">(If we need the new remainder, it can be computed as r̂·B + uₙ₋₂ - q̂·vₙ₋₂.)</span></code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code><span class="comment">The final check u &lt; q̂·v and the possible fixup must be done at full precision.</span></code></span>
<span class="codeline" id="line-200"><code><span class="comment">For random inputs, a fixup at this step is exceedingly rare: the 3-by-2 guess</span></code></span>
<span class="codeline" id="line-201"><code><span class="comment">is not often wrong at all. But still we must do the check. Note that since the</span></code></span>
<span class="codeline" id="line-202"><code><span class="comment">3-by-2 guess is off by at most 1, it can be convenient to perform the final</span></code></span>
<span class="codeline" id="line-203"><code><span class="comment">u &lt; q̂·v as part of the computation of the remainder r = u - q̂·v. If the</span></code></span>
<span class="codeline" id="line-204"><code><span class="comment">subtraction underflows, decremeting q̂ and adding one v back to r is enough to</span></code></span>
<span class="codeline" id="line-205"><code><span class="comment">arrive at the final q, r.</span></code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code><span class="comment">That's the entirety of long division: scale the inputs, and then loop over</span></code></span>
<span class="codeline" id="line-208"><code><span class="comment">each output position, guessing, checking, and correcting the next output digit.</span></code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code><span class="comment">For a 2n-digit number divided by an n-digit number (the worst size-n case for</span></code></span>
<span class="codeline" id="line-211"><code><span class="comment">division complexity), this algorithm uses n+1 iterations, each of which must do</span></code></span>
<span class="codeline" id="line-212"><code><span class="comment">at least the 1-by-n-digit multiplication q̂·v. That's O(n) iterations of</span></code></span>
<span class="codeline" id="line-213"><code><span class="comment">O(n) time each, so O(n²) time overall.</span></code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code><span class="comment">Recursive Division</span></code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code><span class="comment">For very large inputs, it is possible to improve on the O(n²) algorithm.</span></code></span>
<span class="codeline" id="line-219"><code><span class="comment">Let's call a group of n/2 real digits a (very) “wide digit”. We can run the</span></code></span>
<span class="codeline" id="line-220"><code><span class="comment">standard long division algorithm explained above over the wide digits instead of</span></code></span>
<span class="codeline" id="line-221"><code><span class="comment">the actual digits. This will result in many fewer steps, but the math involved in</span></code></span>
<span class="codeline" id="line-222"><code><span class="comment">each step is more work.</span></code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code><span class="comment">Where basic long division uses a 2-by-1-digit division to guess the initial q̂,</span></code></span>
<span class="codeline" id="line-225"><code><span class="comment">the new algorithm must use a 2-by-1-wide-digit division, which is of course</span></code></span>
<span class="codeline" id="line-226"><code><span class="comment">really an n-by-n/2-digit division. That's OK: if we implement n-digit division</span></code></span>
<span class="codeline" id="line-227"><code><span class="comment">in terms of n/2-digit division, the recursion will terminate when the divisor</span></code></span>
<span class="codeline" id="line-228"><code><span class="comment">becomes small enough to handle with standard long division or even with the</span></code></span>
<span class="codeline" id="line-229"><code><span class="comment">2-by-1 hardware instruction.</span></code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code><span class="comment">For example, here is a sketch of dividing 10 digits by 4, proceeding with</span></code></span>
<span class="codeline" id="line-232"><code><span class="comment">wide digits corresponding to two regular digits. The first step, still special,</span></code></span>
<span class="codeline" id="line-233"><code><span class="comment">must leave off a (regular) digit, dividing 5 by 4 and producing a 4-digit</span></code></span>
<span class="codeline" id="line-234"><code><span class="comment">remainder less than v. The middle steps divide 6 digits by 4, guaranteed to</span></code></span>
<span class="codeline" id="line-235"><code><span class="comment">produce two output digits each (one wide digit) with 4-digit remainders.</span></code></span>
<span class="codeline" id="line-236"><code><span class="comment">The final step must use what it has: the 4-digit remainder plus one more,</span></code></span>
<span class="codeline" id="line-237"><code><span class="comment">5 digits to divide by 4.</span></code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code><span class="comment">	                       q₆ q₅ q₄ q₃ q₂ q₁ q₀</span></code></span>
<span class="codeline" id="line-240"><code><span class="comment">	            _______________________________</span></code></span>
<span class="codeline" id="line-241"><code><span class="comment">	v₃ v₂ v₁ v₀ ) u₉ u₈ u₇ u₆ u₅ u₄ u₃ u₂ u₁ u₀</span></code></span>
<span class="codeline" id="line-242"><code><span class="comment">	              ↓  ↓  ↓  ↓  ↓  |  |  |  |  |</span></code></span>
<span class="codeline" id="line-243"><code><span class="comment">	             [u₉ u₈ u₇ u₆ u₅]|  |  |  |  |</span></code></span>
<span class="codeline" id="line-244"><code><span class="comment">	           - [    q₆q₅·v    ]|  |  |  |  |</span></code></span>
<span class="codeline" id="line-245"><code><span class="comment">	           ----------------- ↓  ↓  |  |  |</span></code></span>
<span class="codeline" id="line-246"><code><span class="comment">	                [    rem    |u₄ u₃]|  |  |</span></code></span>
<span class="codeline" id="line-247"><code><span class="comment">	              - [     q₄q₃·v      ]|  |  |</span></code></span>
<span class="codeline" id="line-248"><code><span class="comment">	              -------------------- ↓  ↓  |</span></code></span>
<span class="codeline" id="line-249"><code><span class="comment">	                      [    rem    |u₂ u₁]|</span></code></span>
<span class="codeline" id="line-250"><code><span class="comment">	                    - [     q₂q₁·v      ]|</span></code></span>
<span class="codeline" id="line-251"><code><span class="comment">	                    -------------------- ↓</span></code></span>
<span class="codeline" id="line-252"><code><span class="comment">	                            [    rem    |u₀]</span></code></span>
<span class="codeline" id="line-253"><code><span class="comment">	                          - [     q₀·v     ]</span></code></span>
<span class="codeline" id="line-254"><code><span class="comment">	                          ------------------</span></code></span>
<span class="codeline" id="line-255"><code><span class="comment">	                               [    rem    ]</span></code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code><span class="comment">An alternative would be to look ahead to how well n/2 divides into n+m and</span></code></span>
<span class="codeline" id="line-258"><code><span class="comment">adjust the first step to use fewer digits as needed, making the first step</span></code></span>
<span class="codeline" id="line-259"><code><span class="comment">more special to make the last step not special at all. For example, using the</span></code></span>
<span class="codeline" id="line-260"><code><span class="comment">same input, we could choose to use only 4 digits in the first step, leaving</span></code></span>
<span class="codeline" id="line-261"><code><span class="comment">a full wide digit for the last step:</span></code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code><span class="comment">	                       q₆ q₅ q₄ q₃ q₂ q₁ q₀</span></code></span>
<span class="codeline" id="line-264"><code><span class="comment">	            _______________________________</span></code></span>
<span class="codeline" id="line-265"><code><span class="comment">	v₃ v₂ v₁ v₀ ) u₉ u₈ u₇ u₆ u₅ u₄ u₃ u₂ u₁ u₀</span></code></span>
<span class="codeline" id="line-266"><code><span class="comment">	              ↓  ↓  ↓  ↓  |  |  |  |  |  |</span></code></span>
<span class="codeline" id="line-267"><code><span class="comment">	             [u₉ u₈ u₇ u₆]|  |  |  |  |  |</span></code></span>
<span class="codeline" id="line-268"><code><span class="comment">	           - [    q₆·v   ]|  |  |  |  |  |</span></code></span>
<span class="codeline" id="line-269"><code><span class="comment">	           -------------- ↓  ↓  |  |  |  |</span></code></span>
<span class="codeline" id="line-270"><code><span class="comment">	             [    rem    |u₅ u₄]|  |  |  |</span></code></span>
<span class="codeline" id="line-271"><code><span class="comment">	           - [     q₅q₄·v      ]|  |  |  |</span></code></span>
<span class="codeline" id="line-272"><code><span class="comment">	           -------------------- ↓  ↓  |  |</span></code></span>
<span class="codeline" id="line-273"><code><span class="comment">	                   [    rem    |u₃ u₂]|  |</span></code></span>
<span class="codeline" id="line-274"><code><span class="comment">	                 - [     q₃q₂·v      ]|  |</span></code></span>
<span class="codeline" id="line-275"><code><span class="comment">	                 -------------------- ↓  ↓</span></code></span>
<span class="codeline" id="line-276"><code><span class="comment">	                         [    rem    |u₁ u₀]</span></code></span>
<span class="codeline" id="line-277"><code><span class="comment">	                       - [     q₁q₀·v      ]</span></code></span>
<span class="codeline" id="line-278"><code><span class="comment">	                       ---------------------</span></code></span>
<span class="codeline" id="line-279"><code><span class="comment">	                               [    rem    ]</span></code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code><span class="comment">Today, the code in divRecursiveStep works like the first example. Perhaps in</span></code></span>
<span class="codeline" id="line-282"><code><span class="comment">the future we will make it work like the alternative, to avoid a special case</span></code></span>
<span class="codeline" id="line-283"><code><span class="comment">in the final iteration.</span></code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code><span class="comment">Either way, each step is a 3-by-2-wide-digit division approximated first by</span></code></span>
<span class="codeline" id="line-286"><code><span class="comment">a 2-by-1-wide-digit division, just as we did for regular digits in long division.</span></code></span>
<span class="codeline" id="line-287"><code><span class="comment">Because the actual answer we want is a 3-by-2-wide-digit division, instead of</span></code></span>
<span class="codeline" id="line-288"><code><span class="comment">multiplying q̂·v directly during the fixup, we can use the quick refinement</span></code></span>
<span class="codeline" id="line-289"><code><span class="comment">from long division (an n/2-by-n/2 multiply) to correct q to its actual value</span></code></span>
<span class="codeline" id="line-290"><code><span class="comment">and also compute the remainder (as mentioned above), and then stop after that,</span></code></span>
<span class="codeline" id="line-291"><code><span class="comment">never doing a full n-by-n multiply.</span></code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code><span class="comment">Instead of using an n-by-n/2-digit division to produce n/2 digits, we can add</span></code></span>
<span class="codeline" id="line-294"><code><span class="comment">(not discard) one more real digit, doing an (n+1)-by-(n/2+1)-digit division that</span></code></span>
<span class="codeline" id="line-295"><code><span class="comment">produces n/2+1 digits. That single extra digit tightens the Good Guess Guarantee</span></code></span>
<span class="codeline" id="line-296"><code><span class="comment">to q ≤ q̂ ≤ q+1 and lets us drop long division's special treatment of the first</span></code></span>
<span class="codeline" id="line-297"><code><span class="comment">digit. These benefits are discussed more after the Good Guess Guarantee proof</span></code></span>
<span class="codeline" id="line-298"><code><span class="comment">below.</span></code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code><span class="comment">How Fast is Recursive Division?</span></code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code><span class="comment">For a 2n-by-n-digit division, this algorithm runs a 4-by-2 long division over</span></code></span>
<span class="codeline" id="line-304"><code><span class="comment">wide digits, producing two wide digits plus a possible leading regular digit 1,</span></code></span>
<span class="codeline" id="line-305"><code><span class="comment">which can be handled without a recursive call. That is, the algorithm uses two</span></code></span>
<span class="codeline" id="line-306"><code><span class="comment">full iterations, each using an n-by-n/2-digit division and an n/2-by-n/2-digit</span></code></span>
<span class="codeline" id="line-307"><code><span class="comment">multiplication, along with a few n-digit additions and subtractions. The standard</span></code></span>
<span class="codeline" id="line-308"><code><span class="comment">n-by-n-digit multiplication algorithm requires O(n²) time, making the overall</span></code></span>
<span class="codeline" id="line-309"><code><span class="comment">algorithm require time T(n) where</span></code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code><span class="comment">	T(n) = 2T(n/2) + O(n) + O(n²)</span></code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code><span class="comment">which, by the Bentley-Haken-Saxe theorem, ends up reducing to T(n) = O(n²).</span></code></span>
<span class="codeline" id="line-314"><code><span class="comment">This is not an improvement over regular long division.</span></code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code><span class="comment">When the number of digits n becomes large enough, Karatsuba's algorithm for</span></code></span>
<span class="codeline" id="line-317"><code><span class="comment">multiplication can be used instead, which takes O(n^log₂3) = O(n^1.6) time.</span></code></span>
<span class="codeline" id="line-318"><code><span class="comment">(Karatsuba multiplication is implemented in func karatsuba in nat.go.)</span></code></span>
<span class="codeline" id="line-319"><code><span class="comment">That makes the overall recursive division algorithm take O(n^1.6) time as well,</span></code></span>
<span class="codeline" id="line-320"><code><span class="comment">which is an improvement, but again only for large enough numbers.</span></code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code><span class="comment">It is not critical to make sure that every recursion does only two recursive</span></code></span>
<span class="codeline" id="line-323"><code><span class="comment">calls. While in general the number of recursive calls can change the time</span></code></span>
<span class="codeline" id="line-324"><code><span class="comment">analysis, in this case doing three calls does not change the analysis:</span></code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code><span class="comment">	T(n) = 3T(n/2) + O(n) + O(n^log₂3)</span></code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code><span class="comment">ends up being T(n) = O(n^log₂3). Because the Karatsuba multiplication taking</span></code></span>
<span class="codeline" id="line-329"><code><span class="comment">time O(n^log₂3) is itself doing 3 half-sized recursions, doing three for the</span></code></span>
<span class="codeline" id="line-330"><code><span class="comment">division does not hurt the asymptotic performance. Of course, it is likely</span></code></span>
<span class="codeline" id="line-331"><code><span class="comment">still faster in practice to do two.</span></code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code><span class="comment">Proof of the Good Guess Guarantee</span></code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code><span class="comment">Given numbers x, y, let us break them into the quotients and remainders when</span></code></span>
<span class="codeline" id="line-337"><code><span class="comment">divided by some scaling factor S, with the added constraints that the quotient</span></code></span>
<span class="codeline" id="line-338"><code><span class="comment">x/y and the high part of y are both less than some limit T, and that the high</span></code></span>
<span class="codeline" id="line-339"><code><span class="comment">part of y is at least half as big as T.</span></code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code><span class="comment">	x₁ = ⌊x/S⌋        y₁ = ⌊y/S⌋</span></code></span>
<span class="codeline" id="line-342"><code><span class="comment">	x₀ = x mod S      y₀ = y mod S</span></code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code><span class="comment">	x  = x₁·S + x₀    0 ≤ x₀ &lt; S    x/y &lt; T</span></code></span>
<span class="codeline" id="line-345"><code><span class="comment">	y  = y₁·S + y₀    0 ≤ y₀ &lt; S    T/2 ≤ y₁ &lt; T</span></code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code><span class="comment">And consider the two truncated quotients:</span></code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code><span class="comment">	q = ⌊x/y⌋</span></code></span>
<span class="codeline" id="line-350"><code><span class="comment">	q̂ = ⌊x₁/y₁⌋</span></code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code><span class="comment">We will prove that q ≤ q̂ ≤ q+2.</span></code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code><span class="comment">The guarantee makes no real demands on the scaling factor S: it is simply the</span></code></span>
<span class="codeline" id="line-355"><code><span class="comment">magnitude of the digits cut from both x and y to produce x₁ and y₁.</span></code></span>
<span class="codeline" id="line-356"><code><span class="comment">The guarantee makes only limited demands on T: it must be large enough to hold</span></code></span>
<span class="codeline" id="line-357"><code><span class="comment">the quotient x/y, and y₁ must have roughly the same size.</span></code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code><span class="comment">To apply to the earlier discussion of 2-by-1 guesses in long division,</span></code></span>
<span class="codeline" id="line-360"><code><span class="comment">we would choose:</span></code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code><span class="comment">	S  = Bⁿ⁻¹</span></code></span>
<span class="codeline" id="line-363"><code><span class="comment">	T  = B</span></code></span>
<span class="codeline" id="line-364"><code><span class="comment">	x  = u</span></code></span>
<span class="codeline" id="line-365"><code><span class="comment">	x₁ = uₙuₙ₋₁</span></code></span>
<span class="codeline" id="line-366"><code><span class="comment">	x₀ = uₙ₋₂...u₀</span></code></span>
<span class="codeline" id="line-367"><code><span class="comment">	y  = v</span></code></span>
<span class="codeline" id="line-368"><code><span class="comment">	y₁ = vₙ₋₁</span></code></span>
<span class="codeline" id="line-369"><code><span class="comment">	y₀ = vₙ₋₂...u₀</span></code></span>
<span class="codeline" id="line-370"><code></code></span>
<span class="codeline" id="line-371"><code><span class="comment">These simpler variables avoid repeating those longer expressions in the proof.</span></code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code><span class="comment">Note also that, by definition, truncating division ⌊x/y⌋ satisfies</span></code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code><span class="comment">	x/y - 1 &lt; ⌊x/y⌋ ≤ x/y.</span></code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code><span class="comment">This fact will be used a few times in the proofs.</span></code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code><span class="comment">Proof that q ≤ q̂:</span></code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code><span class="comment">	q̂·y₁ = ⌊x₁/y₁⌋·y₁                      [by definition, q̂ = ⌊x₁/y₁⌋]</span></code></span>
<span class="codeline" id="line-382"><code><span class="comment">	     &gt; (x₁/y₁ - 1)·y₁                  [x₁/y₁ - 1 &lt; ⌊x₁/y₁⌋]</span></code></span>
<span class="codeline" id="line-383"><code><span class="comment">	     = x₁ - y₁                         [distribute y₁]</span></code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code><span class="comment">	So q̂·y₁ &gt; x₁ - y₁.</span></code></span>
<span class="codeline" id="line-386"><code><span class="comment">	Since q̂·y₁ is an integer, q̂·y₁ ≥ x₁ - y₁ + 1.</span></code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code><span class="comment">	q̂ - q = q̂ - ⌊x/y⌋                      [by definition, q = ⌊x/y⌋]</span></code></span>
<span class="codeline" id="line-389"><code><span class="comment">	      ≥ q̂ - x/y                        [⌊x/y⌋ &lt; x/y]</span></code></span>
<span class="codeline" id="line-390"><code><span class="comment">	      = (1/y)·(q̂·y - x)                [factor out 1/y]</span></code></span>
<span class="codeline" id="line-391"><code><span class="comment">	      ≥ (1/y)·(q̂·y₁·S - x)             [y = y₁·S + y₀ ≥ y₁·S]</span></code></span>
<span class="codeline" id="line-392"><code><span class="comment">	      ≥ (1/y)·((x₁ - y₁ + 1)·S - x)    [above: q̂·y₁ ≥ x₁ - y₁ + 1]</span></code></span>
<span class="codeline" id="line-393"><code><span class="comment">	      = (1/y)·(x₁·S - y₁·S + S - x)    [distribute S]</span></code></span>
<span class="codeline" id="line-394"><code><span class="comment">	      = (1/y)·(S - x₀ - y₁·S)          [-x = -x₁·S - x₀]</span></code></span>
<span class="codeline" id="line-395"><code><span class="comment">	      &gt; -y₁·S / y                      [x₀ &lt; S, so S - x₀ &lt; 0; drop it]</span></code></span>
<span class="codeline" id="line-396"><code><span class="comment">	      ≥ -1                             [y₁·S ≤ y]</span></code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code><span class="comment">	So q̂ - q &gt; -1.</span></code></span>
<span class="codeline" id="line-399"><code><span class="comment">	Since q̂ - q is an integer, q̂ - q ≥ 0, or equivalently q ≤ q̂.</span></code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code><span class="comment">Proof that q̂ ≤ q+2:</span></code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code><span class="comment">	x₁/y₁ - x/y = x₁·S/y₁·S - x/y          [multiply left term by S/S]</span></code></span>
<span class="codeline" id="line-404"><code><span class="comment">	            ≤ x/y₁·S - x/y             [x₁S ≤ x]</span></code></span>
<span class="codeline" id="line-405"><code><span class="comment">	            = (x/y)·(y/y₁·S - 1)       [factor out x/y]</span></code></span>
<span class="codeline" id="line-406"><code><span class="comment">	            = (x/y)·((y - y₁·S)/y₁·S)  [move -1 into y/y₁·S fraction]</span></code></span>
<span class="codeline" id="line-407"><code><span class="comment">	            = (x/y)·(y₀/y₁·S)          [y - y₁·S = y₀]</span></code></span>
<span class="codeline" id="line-408"><code><span class="comment">	            = (x/y)·(1/y₁)·(y₀/S)      [factor out 1/y₁]</span></code></span>
<span class="codeline" id="line-409"><code><span class="comment">	            &lt; (x/y)·(1/y₁)             [y₀ &lt; S, so y₀/S &lt; 1]</span></code></span>
<span class="codeline" id="line-410"><code><span class="comment">	            ≤ (x/y)·(2/T)              [y₁ ≥ T/2, so 1/y₁ ≤ 2/T]</span></code></span>
<span class="codeline" id="line-411"><code><span class="comment">	            &lt; T·(2/T)                  [x/y &lt; T]</span></code></span>
<span class="codeline" id="line-412"><code><span class="comment">	            = 2                        [T·(2/T) = 2]</span></code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code><span class="comment">	So x₁/y₁ - x/y &lt; 2.</span></code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code><span class="comment">	q̂ - q = ⌊x₁/y₁⌋ - q                    [by definition, q̂ = ⌊x₁/y₁⌋]</span></code></span>
<span class="codeline" id="line-417"><code><span class="comment">	      = ⌊x₁/y₁⌋ - ⌊x/y⌋                [by definition, q = ⌊x/y⌋]</span></code></span>
<span class="codeline" id="line-418"><code><span class="comment">	      ≤ x₁/y₁ - ⌊x/y⌋                  [⌊x₁/y₁⌋ ≤ x₁/y₁]</span></code></span>
<span class="codeline" id="line-419"><code><span class="comment">	      &lt; x₁/y₁ - (x/y - 1)              [⌊x/y⌋ &gt; x/y - 1]</span></code></span>
<span class="codeline" id="line-420"><code><span class="comment">	      = (x₁/y₁ - x/y) + 1              [regrouping]</span></code></span>
<span class="codeline" id="line-421"><code><span class="comment">	      &lt; 2 + 1                          [above: x₁/y₁ - x/y &lt; 2]</span></code></span>
<span class="codeline" id="line-422"><code><span class="comment">	      = 3</span></code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code><span class="comment">	So q̂ - q &lt; 3.</span></code></span>
<span class="codeline" id="line-425"><code><span class="comment">	Since q̂ - q is an integer, q̂ - q ≤ 2.</span></code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code><span class="comment">Note that when x/y &lt; T/2, the bounds tighten to x₁/y₁ - x/y &lt; 1 and therefore</span></code></span>
<span class="codeline" id="line-428"><code><span class="comment">q̂ - q ≤ 1.</span></code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code><span class="comment">Note also that in the general case 2n-by-n division where we don't know that</span></code></span>
<span class="codeline" id="line-431"><code><span class="comment">x/y &lt; T, we do know that x/y &lt; 2T, yielding the bound q̂ - q ≤ 4. So we could</span></code></span>
<span class="codeline" id="line-432"><code><span class="comment">remove the special case first step of long division as long as we allow the</span></code></span>
<span class="codeline" id="line-433"><code><span class="comment">first fixup loop to run up to four times. (Using a simple comparison to decide</span></code></span>
<span class="codeline" id="line-434"><code><span class="comment">whether the first digit is 0 or 1 is still more efficient, though.)</span></code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code><span class="comment">Finally, note that when dividing three leading base-B digits by two (scaled),</span></code></span>
<span class="codeline" id="line-437"><code><span class="comment">we have T = B² and x/y &lt; B = T/B, a much tighter bound than x/y &lt; T.</span></code></span>
<span class="codeline" id="line-438"><code><span class="comment">This in turn yields the much tighter bound x₁/y₁ - x/y &lt; 2/B. This means that</span></code></span>
<span class="codeline" id="line-439"><code><span class="comment">⌊x₁/y₁⌋ and ⌊x/y⌋ can only differ when x/y is less than 2/B greater than an</span></code></span>
<span class="codeline" id="line-440"><code><span class="comment">integer. For random x and y, the chance of this is 2/B, or, for large B,</span></code></span>
<span class="codeline" id="line-441"><code><span class="comment">approximately zero. This means that after we produce the 3-by-2 guess in the</span></code></span>
<span class="codeline" id="line-442"><code><span class="comment">long division algorithm, the fixup loop essentially never runs.</span></code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code><span class="comment">In the recursive algorithm, the extra digit in (2·⌊n/2⌋+1)-by-(⌊n/2⌋+1)-digit</span></code></span>
<span class="codeline" id="line-445"><code><span class="comment">division has exactly the same effect: the probability of needing a fixup is the</span></code></span>
<span class="codeline" id="line-446"><code><span class="comment">same 2/B. Even better, we can allow the general case x/y &lt; 2T and the fixup</span></code></span>
<span class="codeline" id="line-447"><code><span class="comment">probability only grows to 4/B, still essentially zero.</span></code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code><span class="comment">References</span></code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code><span class="comment">There are no great references for implementing long division; thus this comment.</span></code></span>
<span class="codeline" id="line-453"><code><span class="comment">Here are some notes about what to expect from the obvious references.</span></code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code><span class="comment">Knuth Volume 2 (Seminumerical Algorithms) section 4.3.1 is the usual canonical</span></code></span>
<span class="codeline" id="line-456"><code><span class="comment">reference for long division, but that entire series is highly compressed, never</span></code></span>
<span class="codeline" id="line-457"><code><span class="comment">repeating a necessary fact and leaving important insights to the exercises.</span></code></span>
<span class="codeline" id="line-458"><code><span class="comment">For example, no rationale whatsoever is given for the calculation that extends</span></code></span>
<span class="codeline" id="line-459"><code><span class="comment">q̂ from a 2-by-1 to a 3-by-2 guess, nor why it reduces the error bound.</span></code></span>
<span class="codeline" id="line-460"><code><span class="comment">The proof that the calculation even has the desired effect is left to exercises.</span></code></span>
<span class="codeline" id="line-461"><code><span class="comment">The solutions to those exercises provided at the back of the book are entirely</span></code></span>
<span class="codeline" id="line-462"><code><span class="comment">calculations, still with no explanation as to what is going on or how you would</span></code></span>
<span class="codeline" id="line-463"><code><span class="comment">arrive at the idea of doing those exact calculations. Nowhere is it mentioned</span></code></span>
<span class="codeline" id="line-464"><code><span class="comment">that this test extends the 2-by-1 guess into a 3-by-2 guess. The proof of the</span></code></span>
<span class="codeline" id="line-465"><code><span class="comment">Good Guess Guarantee is only for the 2-by-1 guess and argues by contradiction,</span></code></span>
<span class="codeline" id="line-466"><code><span class="comment">making it difficult to understand how modifications like adding another digit</span></code></span>
<span class="codeline" id="line-467"><code><span class="comment">or adjusting the quotient range affects the overall bound.</span></code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code><span class="comment">All that said, Knuth remains the canonical reference. It is dense but packed</span></code></span>
<span class="codeline" id="line-470"><code><span class="comment">full of information and references, and the proofs are simpler than many other</span></code></span>
<span class="codeline" id="line-471"><code><span class="comment">presentations. The proofs above are reworkings of Knuth's to remove the</span></code></span>
<span class="codeline" id="line-472"><code><span class="comment">arguments by contradiction and add explanations or steps that Knuth omitted.</span></code></span>
<span class="codeline" id="line-473"><code><span class="comment">But beware of errors in older printings. Take the published errata with you.</span></code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code><span class="comment">Brinch Hansen's “Multiple-length Division Revisited: a Tour of the Minefield”</span></code></span>
<span class="codeline" id="line-476"><code><span class="comment">starts with a blunt critique of Knuth's presentation (among others) and then</span></code></span>
<span class="codeline" id="line-477"><code><span class="comment">presents a more detailed and easier to follow treatment of long division,</span></code></span>
<span class="codeline" id="line-478"><code><span class="comment">including an implementation in Pascal. But the algorithm and implementation</span></code></span>
<span class="codeline" id="line-479"><code><span class="comment">work entirely in terms of 3-by-2 division, which is much less useful on modern</span></code></span>
<span class="codeline" id="line-480"><code><span class="comment">hardware than an algorithm using 2-by-1 division. The proofs are a bit too</span></code></span>
<span class="codeline" id="line-481"><code><span class="comment">focused on digit counting and seem needlessly complex, especially compared to</span></code></span>
<span class="codeline" id="line-482"><code><span class="comment">the ones given above.</span></code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code><span class="comment">Burnikel and Ziegler's “Fast Recursive Division” introduced the key insight of</span></code></span>
<span class="codeline" id="line-485"><code><span class="comment">implementing division by an n-digit divisor using recursive calls to division</span></code></span>
<span class="codeline" id="line-486"><code><span class="comment">by an n/2-digit divisor, relying on Karatsuba multiplication to yield a</span></code></span>
<span class="codeline" id="line-487"><code><span class="comment">sub-quadratic run time. However, the presentation decisions are made almost</span></code></span>
<span class="codeline" id="line-488"><code><span class="comment">entirely for the purpose of simplifying the run-time analysis, rather than</span></code></span>
<span class="codeline" id="line-489"><code><span class="comment">simplifying the presentation. Instead of a single algorithm that loops over</span></code></span>
<span class="codeline" id="line-490"><code><span class="comment">quotient digits, the paper presents two mutually-recursive algorithms, for</span></code></span>
<span class="codeline" id="line-491"><code><span class="comment">2n-by-n and 3n-by-2n. The paper also does not present any general (n+m)-by-n</span></code></span>
<span class="codeline" id="line-492"><code><span class="comment">algorithm.</span></code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code><span class="comment">The proofs in the paper are remarkably complex, especially considering that</span></code></span>
<span class="codeline" id="line-495"><code><span class="comment">the algorithm is at its core just long division on wide digits, so that the</span></code></span>
<span class="codeline" id="line-496"><code><span class="comment">usual long division proofs apply essentially unaltered.</span></code></span>
<span class="codeline" id="line-497"><code><span class="comment">*/</span></code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code><span class="keyword">package</span> big</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code><span class="keyword">import</span> <label for="i0"><span class="lit-string i0">"math/bits"</span></label></code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code><span class="comment">// div returns q, r such that q = ⌊u/v⌋ and r = u%v = u - q·v.</span></code></span>
<span class="codeline" id="line-504"><code><span class="comment">// It uses z and z2 as the storage for q and r.</span></code></span>
<span class="codeline" id="line-505"><code><span class="keyword">func</span> (<label for="r0" class="ident">z</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r1" class="ident">div</label>(<label for="r2" class="ident">z2</label>, <label for="r3" class="ident">u</label>, <label for="r4" class="ident">v</label> <a href="nat.go.html#line-34" class="ident">nat</a>) (<label for="r5" class="ident">q</label>, <label for="r6" class="ident">r</label> <a href="nat.go.html#line-34" class="ident">nat</a>) {</code></span>
<span class="codeline" id="line-506"><code>	<span class="keyword">if</span> <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r4" class="ident">v</label>) == <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-507"><code>		<a href="../../../pkg/builtin.html#name-panic" class="ident">panic</a>(<span class="lit-string">"division by zero"</span>)</code></span>
<span class="codeline" id="line-508"><code>	}</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>	<span class="keyword">if</span> <label for="r3" class="ident">u</label>.<a href="nat.go.html#line-152" class="ident">cmp</a>(<label for="r4" class="ident">v</label>) &lt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-511"><code>		<label for="r5" class="ident">q</label> = <label for="r0" class="ident">z</label>[:<span class="lit-number">0</span>]</code></span>
<span class="codeline" id="line-512"><code>		<label for="r6" class="ident">r</label> = <label for="r2" class="ident">z2</label>.<a href="nat.go.html#line-92" class="ident">set</a>(<label for="r3" class="ident">u</label>)</code></span>
<span class="codeline" id="line-513"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-514"><code>	}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>	<span class="keyword">if</span> <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r4" class="ident">v</label>) == <span class="lit-number">1</span> {</code></span>
<span class="codeline" id="line-517"><code>		<span class="comment">// Short division: long optimized for a single-word divisor.</span></code></span>
<span class="codeline" id="line-518"><code><span class="comment">		// In that case, the 2-by-1 guess is all we need at each step.</span></code></span>
<span class="codeline" id="line-519"><code>		<span class="keyword">var</span> <label for="r7" class="ident">r2</label> <a href="arith.go.html#line-16" class="ident">Word</a></code></span>
<span class="codeline" id="line-520"><code>		<label for="r5" class="ident">q</label>, <label for="r7" class="ident">r2</label> = <label for="r0" class="ident">z</label>.<a href="#line-532" class="ident">divW</a>(<label for="r3" class="ident">u</label>, <label for="r4" class="ident">v</label>[<span class="lit-number">0</span>])</code></span>
<span class="codeline" id="line-521"><code>		<label for="r6" class="ident">r</label> = <label for="r2" class="ident">z2</label>.<a href="nat.go.html#line-71" class="ident">setWord</a>(<label for="r7" class="ident">r2</label>)</code></span>
<span class="codeline" id="line-522"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-523"><code>	}</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>	<label for="r5" class="ident">q</label>, <label for="r6" class="ident">r</label> = <label for="r0" class="ident">z</label>.<a href="#line-579" class="ident">divLarge</a>(<label for="r2" class="ident">z2</label>, <label for="r3" class="ident">u</label>, <label for="r4" class="ident">v</label>)</code></span>
<span class="codeline" id="line-526"><code>	<span class="keyword">return</span></code></span>
<span class="codeline" id="line-527"><code>}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code><span class="comment">// divW returns q, r such that q = ⌊x/y⌋ and r = x%y = x - q·y.</span></code></span>
<span class="codeline" id="line-530"><code><span class="comment">// It uses z as the storage for q.</span></code></span>
<span class="codeline" id="line-531"><code><span class="comment">// Note that y is a single digit (Word), not a big number.</span></code></span>
<span class="codeline" id="line-532"><code><span class="keyword">func</span> (<label for="r8" class="ident">z</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r9" class="ident">divW</label>(<label for="r10" class="ident">x</label> <a href="nat.go.html#line-34" class="ident">nat</a>, <label for="r11" class="ident">y</label> <a href="arith.go.html#line-16" class="ident">Word</a>) (<label for="r12" class="ident">q</label> <a href="nat.go.html#line-34" class="ident">nat</a>, <label for="r13" class="ident">r</label> <a href="arith.go.html#line-16" class="ident">Word</a>) {</code></span>
<span class="codeline" id="line-533"><code>	<label for="r14" class="ident">m</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r10" class="ident">x</label>)</code></span>
<span class="codeline" id="line-534"><code>	<span class="keyword">switch</span> {</code></span>
<span class="codeline" id="line-535"><code>	<span class="keyword">case</span> <label for="r11" class="ident">y</label> == <span class="lit-number">0</span>:</code></span>
<span class="codeline" id="line-536"><code>		<a href="../../../pkg/builtin.html#name-panic" class="ident">panic</a>(<span class="lit-string">"division by zero"</span>)</code></span>
<span class="codeline" id="line-537"><code>	<span class="keyword">case</span> <label for="r11" class="ident">y</label> == <span class="lit-number">1</span>:</code></span>
<span class="codeline" id="line-538"><code>		<label for="r12" class="ident">q</label> = <label for="r8" class="ident">z</label>.<a href="nat.go.html#line-92" class="ident">set</a>(<label for="r10" class="ident">x</label>) <span class="comment">// result is x</span></code></span>
<span class="codeline" id="line-539"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-540"><code>	<span class="keyword">case</span> <label for="r14" class="ident">m</label> == <span class="lit-number">0</span>:</code></span>
<span class="codeline" id="line-541"><code>		<label for="r12" class="ident">q</label> = <label for="r8" class="ident">z</label>[:<span class="lit-number">0</span>] <span class="comment">// result is 0</span></code></span>
<span class="codeline" id="line-542"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-543"><code>	}</code></span>
<span class="codeline" id="line-544"><code>	<span class="comment">// m &gt; 0</span></code></span>
<span class="codeline" id="line-545"><code>	<label for="r8" class="ident">z</label> = <label for="r8" class="ident">z</label>.<a href="nat.go.html#line-57" class="ident">make</a>(<label for="r14" class="ident">m</label>)</code></span>
<span class="codeline" id="line-546"><code>	<label for="r13" class="ident">r</label> = <a href="#line-561" class="ident">divWVW</a>(<label for="r8" class="ident">z</label>, <span class="lit-number">0</span>, <label for="r10" class="ident">x</label>, <label for="r11" class="ident">y</label>)</code></span>
<span class="codeline" id="line-547"><code>	<label for="r12" class="ident">q</label> = <label for="r8" class="ident">z</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-548"><code>	<span class="keyword">return</span></code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code><span class="comment">// modW returns x % d.</span></code></span>
<span class="codeline" id="line-552"><code><span class="keyword">func</span> (<label for="r15" class="ident">x</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r16" class="ident">modW</label>(<label for="r17" class="ident">d</label> <a href="arith.go.html#line-16" class="ident">Word</a>) (<label for="r18" class="ident">r</label> <a href="arith.go.html#line-16" class="ident">Word</a>) {</code></span>
<span class="codeline" id="line-553"><code>	<span class="comment">// TODO(agl): we don't actually need to store the q value.</span></code></span>
<span class="codeline" id="line-554"><code>	<span class="keyword">var</span> <label for="r19" class="ident">q</label> <a href="nat.go.html#line-34" class="ident">nat</a></code></span>
<span class="codeline" id="line-555"><code>	<label for="r19" class="ident">q</label> = <label for="r19" class="ident">q</label>.<a href="nat.go.html#line-57" class="ident">make</a>(<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r15" class="ident">x</label>))</code></span>
<span class="codeline" id="line-556"><code>	<span class="keyword">return</span> <a href="#line-561" class="ident">divWVW</a>(<label for="r19" class="ident">q</label>, <span class="lit-number">0</span>, <label for="r15" class="ident">x</label>, <label for="r17" class="ident">d</label>)</code></span>
<span class="codeline" id="line-557"><code>}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code><span class="comment">// divWVW overwrites z with ⌊x/y⌋, returning the remainder r.</span></code></span>
<span class="codeline" id="line-560"><code><span class="comment">// The caller must ensure that len(z) = len(x).</span></code></span>
<span class="codeline" id="line-561"><code><span class="keyword">func</span> divWVW(<label for="r21" class="ident">z</label> []<a href="arith.go.html#line-16" class="ident">Word</a>, <label for="r22" class="ident">xn</label> <a href="arith.go.html#line-16" class="ident">Word</a>, <label for="r23" class="ident">x</label> []<a href="arith.go.html#line-16" class="ident">Word</a>, <label for="r24" class="ident">y</label> <a href="arith.go.html#line-16" class="ident">Word</a>) (<label for="r25" class="ident">r</label> <a href="arith.go.html#line-16" class="ident">Word</a>) {</code></span>
<span class="codeline" id="line-562"><code>	<label for="r25" class="ident">r</label> = <label for="r22" class="ident">xn</label></code></span>
<span class="codeline" id="line-563"><code>	<span class="keyword">if</span> <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r23" class="ident">x</label>) == <span class="lit-number">1</span> {</code></span>
<span class="codeline" id="line-564"><code>		<label for="r26" class="ident">qq</label>, <label for="r27" class="ident">rr</label> := <a href="../../../pkg/math/bits.html" class="ident i0">bits</a>.<a href="../bits/bits.go.html#line-486" class="ident">Div</a>(<a href="../../../pkg/builtin.html#name-uint" class="ident">uint</a>(<label for="r25" class="ident">r</label>), <a href="../../../pkg/builtin.html#name-uint" class="ident">uint</a>(<label for="r23" class="ident">x</label>[<span class="lit-number">0</span>]), <a href="../../../pkg/builtin.html#name-uint" class="ident">uint</a>(<label for="r24" class="ident">y</label>))</code></span>
<span class="codeline" id="line-565"><code>		<label for="r21" class="ident">z</label>[<span class="lit-number">0</span>] = <a href="arith.go.html#line-16" class="ident">Word</a>(<label for="r26" class="ident">qq</label>)</code></span>
<span class="codeline" id="line-566"><code>		<span class="keyword">return</span> <a href="arith.go.html#line-16" class="ident">Word</a>(<label for="r27" class="ident">rr</label>)</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code>	<label for="r28" class="ident">rec</label> := <a href="arith.go.html#line-271" class="ident">reciprocalWord</a>(<label for="r24" class="ident">y</label>)</code></span>
<span class="codeline" id="line-569"><code>	<span class="keyword">for</span> <label for="r29" class="ident">i</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r21" class="ident">z</label>) - <span class="lit-number">1</span>; <label for="r29" class="ident">i</label> &gt;= <span class="lit-number">0</span>; <label for="r29" class="ident">i</label>-- {</code></span>
<span class="codeline" id="line-570"><code>		<label for="r21" class="ident">z</label>[<label for="r29" class="ident">i</label>], <label for="r25" class="ident">r</label> = <a href="arith.go.html#line-211" class="ident">divWW</a>(<label for="r25" class="ident">r</label>, <label for="r23" class="ident">x</label>[<label for="r29" class="ident">i</label>], <label for="r24" class="ident">y</label>, <label for="r28" class="ident">rec</label>)</code></span>
<span class="codeline" id="line-571"><code>	}</code></span>
<span class="codeline" id="line-572"><code>	<span class="keyword">return</span> <label for="r25" class="ident">r</label></code></span>
<span class="codeline" id="line-573"><code>}</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code><span class="comment">// div returns q, r such that q = ⌊uIn/vIn⌋ and r = uIn%vIn = uIn - q·vIn.</span></code></span>
<span class="codeline" id="line-576"><code><span class="comment">// It uses z and u as the storage for q and r.</span></code></span>
<span class="codeline" id="line-577"><code><span class="comment">// The caller must ensure that len(vIn) ≥ 2 (use divW otherwise)</span></code></span>
<span class="codeline" id="line-578"><code><span class="comment">// and that len(uIn) ≥ len(vIn) (the answer is 0, uIn otherwise).</span></code></span>
<span class="codeline" id="line-579"><code><span class="keyword">func</span> (<label for="r30" class="ident">z</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r31" class="ident">divLarge</label>(<label for="r32" class="ident">u</label>, <label for="r33" class="ident">uIn</label>, <label for="r34" class="ident">vIn</label> <a href="nat.go.html#line-34" class="ident">nat</a>) (<label for="r35" class="ident">q</label>, <label for="r36" class="ident">r</label> <a href="nat.go.html#line-34" class="ident">nat</a>) {</code></span>
<span class="codeline" id="line-580"><code>	<label for="r37" class="ident">n</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r34" class="ident">vIn</label>)</code></span>
<span class="codeline" id="line-581"><code>	<label for="r38" class="ident">m</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r33" class="ident">uIn</label>) - <label for="r37" class="ident">n</label></code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>	<span class="comment">// Scale the inputs so vIn's top bit is 1 (see “Scaling Inputs” above).</span></code></span>
<span class="codeline" id="line-584"><code><span class="comment">	// vIn is treated as a read-only input (it may be in use by another</span></code></span>
<span class="codeline" id="line-585"><code><span class="comment">	// goroutine), so we must make a copy.</span></code></span>
<span class="codeline" id="line-586"><code><span class="comment">	// uIn is copied to u.</span></code></span>
<span class="codeline" id="line-587"><code>	<label for="r39" class="ident">shift</label> := <a href="arith.go.html#line-59" class="ident">nlz</a>(<label for="r34" class="ident">vIn</label>[<label for="r37" class="ident">n</label>-<span class="lit-number">1</span>])</code></span>
<span class="codeline" id="line-588"><code>	<label for="r40" class="ident">vp</label> := <a href="nat.go.html#line-636" class="ident">getNat</a>(<label for="r37" class="ident">n</label>)</code></span>
<span class="codeline" id="line-589"><code>	<label for="r41" class="ident">v</label> := *<label for="r40" class="ident">vp</label></code></span>
<span class="codeline" id="line-590"><code>	<a href="arith_decl.go.html#line-15" class="ident">shlVU</a>(<label for="r41" class="ident">v</label>, <label for="r34" class="ident">vIn</label>, <label for="r39" class="ident">shift</label>)</code></span>
<span class="codeline" id="line-591"><code>	<label for="r32" class="ident">u</label> = <label for="r32" class="ident">u</label>.<a href="nat.go.html#line-57" class="ident">make</a>(<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r33" class="ident">uIn</label>) + <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-592"><code>	<label for="r32" class="ident">u</label>[<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r33" class="ident">uIn</label>)] = <a href="arith_decl.go.html#line-15" class="ident">shlVU</a>(<label for="r32" class="ident">u</label>[<span class="lit-number">0</span>:<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r33" class="ident">uIn</label>)], <label for="r33" class="ident">uIn</label>, <label for="r39" class="ident">shift</label>)</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>	<span class="comment">// The caller should not pass aliased z and u, since those are</span></code></span>
<span class="codeline" id="line-595"><code><span class="comment">	// the two different outputs, but correct just in case.</span></code></span>
<span class="codeline" id="line-596"><code>	<span class="keyword">if</span> <a href="nat.go.html#line-370" class="ident">alias</a>(<label for="r30" class="ident">z</label>, <label for="r32" class="ident">u</label>) {</code></span>
<span class="codeline" id="line-597"><code>		<label for="r30" class="ident">z</label> = <a href="../../../pkg/builtin.html#name-nil" class="ident">nil</a></code></span>
<span class="codeline" id="line-598"><code>	}</code></span>
<span class="codeline" id="line-599"><code>	<label for="r35" class="ident">q</label> = <label for="r30" class="ident">z</label>.<a href="nat.go.html#line-57" class="ident">make</a>(<label for="r38" class="ident">m</label> + <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>	<span class="comment">// Use basic or recursive long division depending on size.</span></code></span>
<span class="codeline" id="line-602"><code>	<span class="keyword">if</span> <label for="r37" class="ident">n</label> &lt; <a href="#line-709" class="ident">divRecursiveThreshold</a> {</code></span>
<span class="codeline" id="line-603"><code>		<label for="r35" class="ident">q</label>.<a href="#line-621" class="ident">divBasic</a>(<label for="r32" class="ident">u</label>, <label for="r41" class="ident">v</label>)</code></span>
<span class="codeline" id="line-604"><code>	} <span class="keyword">else</span> {</code></span>
<span class="codeline" id="line-605"><code>		<label for="r35" class="ident">q</label>.<a href="#line-716" class="ident">divRecursive</a>(<label for="r32" class="ident">u</label>, <label for="r41" class="ident">v</label>)</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code>	<a href="nat.go.html#line-648" class="ident">putNat</a>(<label for="r40" class="ident">vp</label>)</code></span>
<span class="codeline" id="line-608"><code></code></span>
<span class="codeline" id="line-609"><code>	<label for="r35" class="ident">q</label> = <label for="r35" class="ident">q</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>	<span class="comment">// Undo scaling of remainder.</span></code></span>
<span class="codeline" id="line-612"><code>	<a href="arith_decl.go.html#line-16" class="ident">shrVU</a>(<label for="r32" class="ident">u</label>, <label for="r32" class="ident">u</label>, <label for="r39" class="ident">shift</label>)</code></span>
<span class="codeline" id="line-613"><code>	<label for="r36" class="ident">r</label> = <label for="r32" class="ident">u</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>	<span class="keyword">return</span> <label for="r35" class="ident">q</label>, <label for="r36" class="ident">r</label></code></span>
<span class="codeline" id="line-616"><code>}</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code><span class="comment">// divBasic implements long division as described above.</span></code></span>
<span class="codeline" id="line-619"><code><span class="comment">// It overwrites q with ⌊u/v⌋ and overwrites u with the remainder r.</span></code></span>
<span class="codeline" id="line-620"><code><span class="comment">// q must be large enough to hold ⌊u/v⌋.</span></code></span>
<span class="codeline" id="line-621"><code><span class="keyword">func</span> (<label for="r42" class="ident">q</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r43" class="ident">divBasic</label>(<label for="r44" class="ident">u</label>, <label for="r45" class="ident">v</label> <a href="nat.go.html#line-34" class="ident">nat</a>) {</code></span>
<span class="codeline" id="line-622"><code>	<label for="r46" class="ident">n</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r45" class="ident">v</label>)</code></span>
<span class="codeline" id="line-623"><code>	<label for="r47" class="ident">m</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r44" class="ident">u</label>) - <label for="r46" class="ident">n</label></code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>	<label for="r48" class="ident">qhatvp</label> := <a href="nat.go.html#line-636" class="ident">getNat</a>(<label for="r46" class="ident">n</label> + <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-626"><code>	<label for="r49" class="ident">qhatv</label> := *<label for="r48" class="ident">qhatvp</label></code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>	<span class="comment">// Set up for divWW below, precomputing reciprocal argument.</span></code></span>
<span class="codeline" id="line-629"><code>	<label for="r50" class="ident">vn1</label> := <label for="r45" class="ident">v</label>[<label for="r46" class="ident">n</label>-<span class="lit-number">1</span>]</code></span>
<span class="codeline" id="line-630"><code>	<label for="r51" class="ident">rec</label> := <a href="arith.go.html#line-271" class="ident">reciprocalWord</a>(<label for="r50" class="ident">vn1</label>)</code></span>
<span class="codeline" id="line-631"><code></code></span>
<span class="codeline" id="line-632"><code>	<span class="comment">// Compute each digit of quotient.</span></code></span>
<span class="codeline" id="line-633"><code>	<span class="keyword">for</span> <label for="r52" class="ident">j</label> := <label for="r47" class="ident">m</label>; <label for="r52" class="ident">j</label> &gt;= <span class="lit-number">0</span>; <label for="r52" class="ident">j</label>-- {</code></span>
<span class="codeline" id="line-634"><code>		<span class="comment">// Compute the 2-by-1 guess q̂.</span></code></span>
<span class="codeline" id="line-635"><code><span class="comment">		// The first iteration must invent a leading 0 for u.</span></code></span>
<span class="codeline" id="line-636"><code>		<label for="r53" class="ident">qhat</label> := <a href="arith.go.html#line-16" class="ident">Word</a>(<a href="arith.go.html#line-23" class="ident">_M</a>)</code></span>
<span class="codeline" id="line-637"><code>		<span class="keyword">var</span> <label for="r54" class="ident">ujn</label> <a href="arith.go.html#line-16" class="ident">Word</a></code></span>
<span class="codeline" id="line-638"><code>		<span class="keyword">if</span> <label for="r52" class="ident">j</label>+<label for="r46" class="ident">n</label> &lt; <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r44" class="ident">u</label>) {</code></span>
<span class="codeline" id="line-639"><code>			<label for="r54" class="ident">ujn</label> = <label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>+<label for="r46" class="ident">n</label>]</code></span>
<span class="codeline" id="line-640"><code>		}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>		<span class="comment">// ujn ≤ vn1, or else q̂ would be more than one digit.</span></code></span>
<span class="codeline" id="line-643"><code><span class="comment">		// For ujn == vn1, we set q̂ to the max digit M above.</span></code></span>
<span class="codeline" id="line-644"><code><span class="comment">		// Otherwise, we compute the 2-by-1 guess.</span></code></span>
<span class="codeline" id="line-645"><code>		<span class="keyword">if</span> <label for="r54" class="ident">ujn</label> != <label for="r50" class="ident">vn1</label> {</code></span>
<span class="codeline" id="line-646"><code>			<span class="keyword">var</span> <label for="r55" class="ident">rhat</label> <a href="arith.go.html#line-16" class="ident">Word</a></code></span>
<span class="codeline" id="line-647"><code>			<label for="r53" class="ident">qhat</label>, <label for="r55" class="ident">rhat</label> = <a href="arith.go.html#line-211" class="ident">divWW</a>(<label for="r54" class="ident">ujn</label>, <label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>+<label for="r46" class="ident">n</label>-<span class="lit-number">1</span>], <label for="r50" class="ident">vn1</label>, <label for="r51" class="ident">rec</label>)</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>			<span class="comment">// Refine q̂ to a 3-by-2 guess. See “Refining Guesses” above.</span></code></span>
<span class="codeline" id="line-650"><code>			<label for="r56" class="ident">vn2</label> := <label for="r45" class="ident">v</label>[<label for="r46" class="ident">n</label>-<span class="lit-number">2</span>]</code></span>
<span class="codeline" id="line-651"><code>			<label for="r57" class="ident">x1</label>, <label for="r58" class="ident">x2</label> := <a href="arith.go.html#line-44" class="ident">mulWW</a>(<label for="r53" class="ident">qhat</label>, <label for="r56" class="ident">vn2</label>)</code></span>
<span class="codeline" id="line-652"><code>			<label for="r59" class="ident">ujn2</label> := <label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>+<label for="r46" class="ident">n</label>-<span class="lit-number">2</span>]</code></span>
<span class="codeline" id="line-653"><code>			<span class="keyword">for</span> <a href="#line-703" class="ident">greaterThan</a>(<label for="r57" class="ident">x1</label>, <label for="r58" class="ident">x2</label>, <label for="r55" class="ident">rhat</label>, <label for="r59" class="ident">ujn2</label>) { <span class="comment">// x1x2 &gt; r̂ u[j+n-2]</span></code></span>
<span class="codeline" id="line-654"><code>				<label for="r53" class="ident">qhat</label>--</code></span>
<span class="codeline" id="line-655"><code>				<label for="r60" class="ident">prevRhat</label> := <label for="r55" class="ident">rhat</label></code></span>
<span class="codeline" id="line-656"><code>				<label for="r55" class="ident">rhat</label> += <label for="r50" class="ident">vn1</label></code></span>
<span class="codeline" id="line-657"><code>				<span class="comment">// If r̂  overflows, then</span></code></span>
<span class="codeline" id="line-658"><code><span class="comment">				// r̂ u[j+n-2]v[n-1] is now definitely &gt; x1 x2.</span></code></span>
<span class="codeline" id="line-659"><code>				<span class="keyword">if</span> <label for="r55" class="ident">rhat</label> &lt; <label for="r60" class="ident">prevRhat</label> {</code></span>
<span class="codeline" id="line-660"><code>					<span class="keyword">break</span></code></span>
<span class="codeline" id="line-661"><code>				}</code></span>
<span class="codeline" id="line-662"><code>				<span class="comment">// TODO(rsc): No need for a full mulWW.</span></code></span>
<span class="codeline" id="line-663"><code><span class="comment">				// x2 += vn2; if x2 overflows, x1++</span></code></span>
<span class="codeline" id="line-664"><code>				<label for="r57" class="ident">x1</label>, <label for="r58" class="ident">x2</label> = <a href="arith.go.html#line-44" class="ident">mulWW</a>(<label for="r53" class="ident">qhat</label>, <label for="r56" class="ident">vn2</label>)</code></span>
<span class="codeline" id="line-665"><code>			}</code></span>
<span class="codeline" id="line-666"><code>		}</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>		<span class="comment">// Compute q̂·v.</span></code></span>
<span class="codeline" id="line-669"><code>		<label for="r49" class="ident">qhatv</label>[<label for="r46" class="ident">n</label>] = <a href="arith_decl.go.html#line-17" class="ident">mulAddVWW</a>(<label for="r49" class="ident">qhatv</label>[<span class="lit-number">0</span>:<label for="r46" class="ident">n</label>], <label for="r45" class="ident">v</label>, <label for="r53" class="ident">qhat</label>, <span class="lit-number">0</span>)</code></span>
<span class="codeline" id="line-670"><code>		<label for="r61" class="ident">qhl</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r49" class="ident">qhatv</label>)</code></span>
<span class="codeline" id="line-671"><code>		<span class="keyword">if</span> <label for="r52" class="ident">j</label>+<label for="r61" class="ident">qhl</label> &gt; <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r44" class="ident">u</label>) &amp;&amp; <label for="r49" class="ident">qhatv</label>[<label for="r46" class="ident">n</label>] == <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-672"><code>			<label for="r61" class="ident">qhl</label>--</code></span>
<span class="codeline" id="line-673"><code>		}</code></span>
<span class="codeline" id="line-674"><code></code></span>
<span class="codeline" id="line-675"><code>		<span class="comment">// Subtract q̂·v from the current section of u.</span></code></span>
<span class="codeline" id="line-676"><code><span class="comment">		// If it underflows, q̂·v &gt; u, which we fix up</span></code></span>
<span class="codeline" id="line-677"><code><span class="comment">		// by decrementing q̂ and adding v back.</span></code></span>
<span class="codeline" id="line-678"><code>		<label for="r62" class="ident">c</label> := <a href="arith_decl.go.html#line-12" class="ident">subVV</a>(<label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>:<label for="r52" class="ident">j</label>+<label for="r61" class="ident">qhl</label>], <label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>:], <label for="r49" class="ident">qhatv</label>)</code></span>
<span class="codeline" id="line-679"><code>		<span class="keyword">if</span> <label for="r62" class="ident">c</label> != <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-680"><code>			<label for="r63" class="ident">c</label> := <a href="arith_decl.go.html#line-11" class="ident">addVV</a>(<label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>:<label for="r52" class="ident">j</label>+<label for="r46" class="ident">n</label>], <label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>:], <label for="r45" class="ident">v</label>)</code></span>
<span class="codeline" id="line-681"><code>			<span class="comment">// If n == qhl, the carry from subVV and the carry from addVV</span></code></span>
<span class="codeline" id="line-682"><code><span class="comment">			// cancel out and don't affect u[j+n].</span></code></span>
<span class="codeline" id="line-683"><code>			<span class="keyword">if</span> <label for="r46" class="ident">n</label> &lt; <label for="r61" class="ident">qhl</label> {</code></span>
<span class="codeline" id="line-684"><code>				<label for="r44" class="ident">u</label>[<label for="r52" class="ident">j</label>+<label for="r46" class="ident">n</label>] += <label for="r63" class="ident">c</label></code></span>
<span class="codeline" id="line-685"><code>			}</code></span>
<span class="codeline" id="line-686"><code>			<label for="r53" class="ident">qhat</label>--</code></span>
<span class="codeline" id="line-687"><code>		}</code></span>
<span class="codeline" id="line-688"><code></code></span>
<span class="codeline" id="line-689"><code>		<span class="comment">// Save quotient digit.</span></code></span>
<span class="codeline" id="line-690"><code><span class="comment">		// Caller may know the top digit is zero and not leave room for it.</span></code></span>
<span class="codeline" id="line-691"><code>		<span class="keyword">if</span> <label for="r52" class="ident">j</label> == <label for="r47" class="ident">m</label> &amp;&amp; <label for="r47" class="ident">m</label> == <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r42" class="ident">q</label>) &amp;&amp; <label for="r53" class="ident">qhat</label> == <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-692"><code>			<span class="keyword">continue</span></code></span>
<span class="codeline" id="line-693"><code>		}</code></span>
<span class="codeline" id="line-694"><code>		<label for="r42" class="ident">q</label>[<label for="r52" class="ident">j</label>] = <label for="r53" class="ident">qhat</label></code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>	<a href="nat.go.html#line-648" class="ident">putNat</a>(<label for="r48" class="ident">qhatvp</label>)</code></span>
<span class="codeline" id="line-698"><code>}</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code><span class="comment">// greaterThan reports whether the two digit numbers x1 x2 &gt; y1 y2.</span></code></span>
<span class="codeline" id="line-701"><code><span class="comment">// TODO(rsc): In contradiction to most of this file, x1 is the high</span></code></span>
<span class="codeline" id="line-702"><code><span class="comment">// digit and x2 is the low digit. This should be fixed.</span></code></span>
<span class="codeline" id="line-703"><code><span class="keyword">func</span> greaterThan(<label for="r65" class="ident">x1</label>, <label for="r66" class="ident">x2</label>, <label for="r67" class="ident">y1</label>, <label for="r68" class="ident">y2</label> <a href="arith.go.html#line-16" class="ident">Word</a>) <a href="../../../pkg/builtin.html#name-bool" class="ident">bool</a> {</code></span>
<span class="codeline" id="line-704"><code>	<span class="keyword">return</span> <label for="r65" class="ident">x1</label> &gt; <label for="r67" class="ident">y1</label> || <label for="r65" class="ident">x1</label> == <label for="r67" class="ident">y1</label> &amp;&amp; <label for="r66" class="ident">x2</label> &gt; <label for="r68" class="ident">y2</label></code></span>
<span class="codeline" id="line-705"><code>}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code><span class="comment">// divRecursiveThreshold is the number of divisor digits</span></code></span>
<span class="codeline" id="line-708"><code><span class="comment">// at which point divRecursive is faster than divBasic.</span></code></span>
<span class="codeline" id="line-709"><code><span class="keyword">const</span> divRecursiveThreshold = <span class="lit-number">100</span></code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code><span class="comment">// divRecursive implements recursive division as described above.</span></code></span>
<span class="codeline" id="line-712"><code><span class="comment">// It overwrites z with ⌊u/v⌋ and overwrites u with the remainder r.</span></code></span>
<span class="codeline" id="line-713"><code><span class="comment">// z must be large enough to hold ⌊u/v⌋.</span></code></span>
<span class="codeline" id="line-714"><code><span class="comment">// This function is just for allocating and freeing temporaries</span></code></span>
<span class="codeline" id="line-715"><code><span class="comment">// around divRecursiveStep, the real implementation.</span></code></span>
<span class="codeline" id="line-716"><code><span class="keyword">func</span> (<label for="r69" class="ident">z</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r70" class="ident">divRecursive</label>(<label for="r71" class="ident">u</label>, <label for="r72" class="ident">v</label> <a href="nat.go.html#line-34" class="ident">nat</a>) {</code></span>
<span class="codeline" id="line-717"><code>	<span class="comment">// Recursion depth is (much) less than 2 log₂(len(v)).</span></code></span>
<span class="codeline" id="line-718"><code><span class="comment">	// Allocate a slice of temporaries to be reused across recursion,</span></code></span>
<span class="codeline" id="line-719"><code><span class="comment">	// plus one extra temporary not live across the recursion.</span></code></span>
<span class="codeline" id="line-720"><code>	<label for="r73" class="ident">recDepth</label> := <span class="lit-number">2</span> * <a href="../../../pkg/math/bits.html" class="ident i0">bits</a>.<a href="../bits/bits.go.html#line-296" class="ident">Len</a>(<a href="../../../pkg/builtin.html#name-uint" class="ident">uint</a>(<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r72" class="ident">v</label>)))</code></span>
<span class="codeline" id="line-721"><code>	<label for="r74" class="ident">tmp</label> := <a href="nat.go.html#line-636" class="ident">getNat</a>(<span class="lit-number">3</span> * <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r72" class="ident">v</label>))</code></span>
<span class="codeline" id="line-722"><code>	<label for="r75" class="ident">temps</label> := <a href="../../../pkg/builtin.html#name-make" class="ident">make</a>([]*<a href="nat.go.html#line-34" class="ident">nat</a>, <label for="r73" class="ident">recDepth</label>)</code></span>
<span class="codeline" id="line-723"><code></code></span>
<span class="codeline" id="line-724"><code>	<label for="r69" class="ident">z</label>.<a href="nat.go.html#line-43" class="ident">clear</a>()</code></span>
<span class="codeline" id="line-725"><code>	<label for="r69" class="ident">z</label>.<a href="#line-741" class="ident">divRecursiveStep</a>(<label for="r71" class="ident">u</label>, <label for="r72" class="ident">v</label>, <span class="lit-number">0</span>, <label for="r74" class="ident">tmp</label>, <label for="r75" class="ident">temps</label>)</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>	<span class="comment">// Free temporaries.</span></code></span>
<span class="codeline" id="line-728"><code>	<span class="keyword">for</span> <label for="r76" class="ident">_</label>, <label for="r77" class="ident">n</label> := <span class="keyword">range</span> <label for="r75" class="ident">temps</label> {</code></span>
<span class="codeline" id="line-729"><code>		<span class="keyword">if</span> <label for="r77" class="ident">n</label> != <a href="../../../pkg/builtin.html#name-nil" class="ident">nil</a> {</code></span>
<span class="codeline" id="line-730"><code>			<a href="nat.go.html#line-648" class="ident">putNat</a>(<label for="r77" class="ident">n</label>)</code></span>
<span class="codeline" id="line-731"><code>		}</code></span>
<span class="codeline" id="line-732"><code>	}</code></span>
<span class="codeline" id="line-733"><code>	<a href="nat.go.html#line-648" class="ident">putNat</a>(<label for="r74" class="ident">tmp</label>)</code></span>
<span class="codeline" id="line-734"><code>}</code></span>
<span class="codeline" id="line-735"><code></code></span>
<span class="codeline" id="line-736"><code><span class="comment">// divRecursiveStep is the actual implementation of recursive division.</span></code></span>
<span class="codeline" id="line-737"><code><span class="comment">// It adds ⌊u/v⌋ to z and overwrites u with the remainder r.</span></code></span>
<span class="codeline" id="line-738"><code><span class="comment">// z must be large enough to hold ⌊u/v⌋.</span></code></span>
<span class="codeline" id="line-739"><code><span class="comment">// It uses temps[depth] (allocating if needed) as a temporary live across</span></code></span>
<span class="codeline" id="line-740"><code><span class="comment">// the recursive call. It also uses tmp, but not live across the recursion.</span></code></span>
<span class="codeline" id="line-741"><code><span class="keyword">func</span> (<label for="r78" class="ident">z</label> <a href="nat.go.html#line-34" class="ident">nat</a>) <label for="r79" class="ident">divRecursiveStep</label>(<label for="r80" class="ident">u</label>, <label for="r81" class="ident">v</label> <a href="nat.go.html#line-34" class="ident">nat</a>, <label for="r82" class="ident">depth</label> <a href="../../../pkg/builtin.html#name-int" class="ident">int</a>, <label for="r83" class="ident">tmp</label> *<a href="nat.go.html#line-34" class="ident">nat</a>, <label for="r84" class="ident">temps</label> []*<a href="nat.go.html#line-34" class="ident">nat</a>) {</code></span>
<span class="codeline" id="line-742"><code>	<span class="comment">// u is a subsection of the original and may have leading zeros.</span></code></span>
<span class="codeline" id="line-743"><code><span class="comment">	// TODO(rsc): The v = v.norm() is useless and should be removed.</span></code></span>
<span class="codeline" id="line-744"><code><span class="comment">	// We know (and require) that v's top digit is ≥ B/2.</span></code></span>
<span class="codeline" id="line-745"><code>	<label for="r80" class="ident">u</label> = <label for="r80" class="ident">u</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-746"><code>	<label for="r81" class="ident">v</label> = <label for="r81" class="ident">v</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-747"><code>	<span class="keyword">if</span> <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r80" class="ident">u</label>) == <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-748"><code>		<label for="r78" class="ident">z</label>.<a href="nat.go.html#line-43" class="ident">clear</a>()</code></span>
<span class="codeline" id="line-749"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-750"><code>	}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>	<span class="comment">// Fall back to basic division if the problem is now small enough.</span></code></span>
<span class="codeline" id="line-753"><code>	<label for="r85" class="ident">n</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r81" class="ident">v</label>)</code></span>
<span class="codeline" id="line-754"><code>	<span class="keyword">if</span> <label for="r85" class="ident">n</label> &lt; <a href="#line-709" class="ident">divRecursiveThreshold</a> {</code></span>
<span class="codeline" id="line-755"><code>		<label for="r78" class="ident">z</label>.<a href="#line-621" class="ident">divBasic</a>(<label for="r80" class="ident">u</label>, <label for="r81" class="ident">v</label>)</code></span>
<span class="codeline" id="line-756"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-757"><code>	}</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>	<span class="comment">// Nothing to do if u is shorter than v (implies u &lt; v).</span></code></span>
<span class="codeline" id="line-760"><code>	<label for="r86" class="ident">m</label> := <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r80" class="ident">u</label>) - <label for="r85" class="ident">n</label></code></span>
<span class="codeline" id="line-761"><code>	<span class="keyword">if</span> <label for="r86" class="ident">m</label> &lt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-762"><code>		<span class="keyword">return</span></code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>	<span class="comment">// We consider B digits in a row as a single wide digit.</span></code></span>
<span class="codeline" id="line-766"><code><span class="comment">	// (See “Recursive Division” above.)</span></code></span>
<span class="codeline" id="line-767"><code><span class="comment">	//</span></code></span>
<span class="codeline" id="line-768"><code><span class="comment">	// TODO(rsc): rename B to Wide, to avoid confusion with _B,</span></code></span>
<span class="codeline" id="line-769"><code><span class="comment">	// which is something entirely different.</span></code></span>
<span class="codeline" id="line-770"><code><span class="comment">	// TODO(rsc): Look into whether using ⌈n/2⌉ is better than ⌊n/2⌋.</span></code></span>
<span class="codeline" id="line-771"><code>	<label for="r87" class="ident">B</label> := <label for="r85" class="ident">n</label> / <span class="lit-number">2</span></code></span>
<span class="codeline" id="line-772"><code></code></span>
<span class="codeline" id="line-773"><code>	<span class="comment">// Allocate a nat for qhat below.</span></code></span>
<span class="codeline" id="line-774"><code>	<span class="keyword">if</span> <label for="r84" class="ident">temps</label>[<label for="r82" class="ident">depth</label>] == <a href="../../../pkg/builtin.html#name-nil" class="ident">nil</a> {</code></span>
<span class="codeline" id="line-775"><code>		<label for="r84" class="ident">temps</label>[<label for="r82" class="ident">depth</label>] = <a href="nat.go.html#line-636" class="ident">getNat</a>(<label for="r85" class="ident">n</label>) <span class="comment">// TODO(rsc): Can be just B+1.</span></code></span>
<span class="codeline" id="line-776"><code>	} <span class="keyword">else</span> {</code></span>
<span class="codeline" id="line-777"><code>		*<label for="r84" class="ident">temps</label>[<label for="r82" class="ident">depth</label>] = <label for="r84" class="ident">temps</label>[<label for="r82" class="ident">depth</label>].<a href="nat.go.html#line-57" class="ident">make</a>(<label for="r87" class="ident">B</label> + <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-778"><code>	}</code></span>
<span class="codeline" id="line-779"><code></code></span>
<span class="codeline" id="line-780"><code>	<span class="comment">// Compute each wide digit of the quotient.</span></code></span>
<span class="codeline" id="line-781"><code><span class="comment">	//</span></code></span>
<span class="codeline" id="line-782"><code><span class="comment">	// TODO(rsc): Change the loop to be</span></code></span>
<span class="codeline" id="line-783"><code><span class="comment">	//	for j := (m+B-1)/B*B; j &gt; 0; j -= B {</span></code></span>
<span class="codeline" id="line-784"><code><span class="comment">	// which will make the final step a regular step, letting us</span></code></span>
<span class="codeline" id="line-785"><code><span class="comment">	// delete what amounts to an extra copy of the loop body below.</span></code></span>
<span class="codeline" id="line-786"><code>	<label for="r88" class="ident">j</label> := <label for="r86" class="ident">m</label></code></span>
<span class="codeline" id="line-787"><code>	<span class="keyword">for</span> <label for="r88" class="ident">j</label> &gt; <label for="r87" class="ident">B</label> {</code></span>
<span class="codeline" id="line-788"><code>		<span class="comment">// Divide u[j-B:j+n] (3 wide digits) by v (2 wide digits).</span></code></span>
<span class="codeline" id="line-789"><code><span class="comment">		// First make the 2-by-1-wide-digit guess using a recursive call.</span></code></span>
<span class="codeline" id="line-790"><code><span class="comment">		// Then extend the guess to the full 3-by-2 (see “Refining Guesses”).</span></code></span>
<span class="codeline" id="line-791"><code><span class="comment">		//</span></code></span>
<span class="codeline" id="line-792"><code><span class="comment">		// For the 2-by-1-wide-digit guess, instead of doing 2B-by-B-digit,</span></code></span>
<span class="codeline" id="line-793"><code><span class="comment">		// we use a (2B+1)-by-(B+1) digit, which handles the possibility that</span></code></span>
<span class="codeline" id="line-794"><code><span class="comment">		// the result has an extra leading 1 digit as well as guaranteeing</span></code></span>
<span class="codeline" id="line-795"><code><span class="comment">		// that the computed q̂ will be off by at most 1 instead of 2.</span></code></span>
<span class="codeline" id="line-796"><code></code></span>
<span class="codeline" id="line-797"><code>		<span class="comment">// s is the number of digits to drop from the 3B- and 2B-digit chunks.</span></code></span>
<span class="codeline" id="line-798"><code><span class="comment">		// We drop B-1 to be left with 2B+1 and B+1.</span></code></span>
<span class="codeline" id="line-799"><code>		<label for="r89" class="ident">s</label> := (<label for="r87" class="ident">B</label> - <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-800"><code></code></span>
<span class="codeline" id="line-801"><code>		<span class="comment">// uu is the up-to-3B-digit section of u we are working on.</span></code></span>
<span class="codeline" id="line-802"><code>		<label for="r90" class="ident">uu</label> := <label for="r80" class="ident">u</label>[<label for="r88" class="ident">j</label>-<label for="r87" class="ident">B</label>:]</code></span>
<span class="codeline" id="line-803"><code></code></span>
<span class="codeline" id="line-804"><code>		<span class="comment">// Compute the 2-by-1 guess q̂, leaving r̂ in uu[s:B+n].</span></code></span>
<span class="codeline" id="line-805"><code>		<label for="r91" class="ident">qhat</label> := *<label for="r84" class="ident">temps</label>[<label for="r82" class="ident">depth</label>]</code></span>
<span class="codeline" id="line-806"><code>		<label for="r91" class="ident">qhat</label>.<a href="nat.go.html#line-43" class="ident">clear</a>()</code></span>
<span class="codeline" id="line-807"><code>		<label for="r91" class="ident">qhat</label>.<label for="r79" class="ident">divRecursiveStep</label>(<label for="r90" class="ident">uu</label>[<label for="r89" class="ident">s</label>:<label for="r87" class="ident">B</label>+<label for="r85" class="ident">n</label>], <label for="r81" class="ident">v</label>[<label for="r89" class="ident">s</label>:], <label for="r82" class="ident">depth</label>+<span class="lit-number">1</span>, <label for="r83" class="ident">tmp</label>, <label for="r84" class="ident">temps</label>)</code></span>
<span class="codeline" id="line-808"><code>		<label for="r91" class="ident">qhat</label> = <label for="r91" class="ident">qhat</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>		<span class="comment">// Extend to a 3-by-2 quotient and remainder.</span></code></span>
<span class="codeline" id="line-811"><code><span class="comment">		// Because divRecursiveStep overwrote the top part of uu with</span></code></span>
<span class="codeline" id="line-812"><code><span class="comment">		// the remainder r̂, the full uu already contains the equivalent</span></code></span>
<span class="codeline" id="line-813"><code><span class="comment">		// of r̂·B + uₙ₋₂ from the “Refining Guesses” discussion.</span></code></span>
<span class="codeline" id="line-814"><code><span class="comment">		// Subtracting q̂·vₙ₋₂ from it will compute the full-length remainder.</span></code></span>
<span class="codeline" id="line-815"><code><span class="comment">		// If that subtraction underflows, q̂·v &gt; u, which we fix up</span></code></span>
<span class="codeline" id="line-816"><code><span class="comment">		// by decrementing q̂ and adding v back, same as in long division.</span></code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>		<span class="comment">// TODO(rsc): Instead of subtract and fix-up, this code is computing</span></code></span>
<span class="codeline" id="line-819"><code><span class="comment">		// q̂·vₙ₋₂ and decrementing q̂ until that product is ≤ u.</span></code></span>
<span class="codeline" id="line-820"><code><span class="comment">		// But we can do the subtraction directly, as in the comment above</span></code></span>
<span class="codeline" id="line-821"><code><span class="comment">		// and in long division, because we know that q̂ is wrong by at most one.</span></code></span>
<span class="codeline" id="line-822"><code>		<label for="r92" class="ident">qhatv</label> := <label for="r83" class="ident">tmp</label>.<a href="nat.go.html#line-57" class="ident">make</a>(<span class="lit-number">3</span> * <label for="r85" class="ident">n</label>)</code></span>
<span class="codeline" id="line-823"><code>		<label for="r92" class="ident">qhatv</label>.<a href="nat.go.html#line-43" class="ident">clear</a>()</code></span>
<span class="codeline" id="line-824"><code>		<label for="r92" class="ident">qhatv</label> = <label for="r92" class="ident">qhatv</label>.<a href="nat.go.html#line-408" class="ident">mul</a>(<label for="r91" class="ident">qhat</label>, <label for="r81" class="ident">v</label>[:<label for="r89" class="ident">s</label>])</code></span>
<span class="codeline" id="line-825"><code>		<span class="keyword">for</span> <label for="r93" class="ident">i</label> := <span class="lit-number">0</span>; <label for="r93" class="ident">i</label> &lt; <span class="lit-number">2</span>; <label for="r93" class="ident">i</label>++ {</code></span>
<span class="codeline" id="line-826"><code>			<label for="r94" class="ident">e</label> := <label for="r92" class="ident">qhatv</label>.<a href="nat.go.html#line-152" class="ident">cmp</a>(<label for="r90" class="ident">uu</label>.<a href="nat.go.html#line-49" class="ident">norm</a>())</code></span>
<span class="codeline" id="line-827"><code>			<span class="keyword">if</span> <label for="r94" class="ident">e</label> &lt;= <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-828"><code>				<span class="keyword">break</span></code></span>
<span class="codeline" id="line-829"><code>			}</code></span>
<span class="codeline" id="line-830"><code>			<a href="arith_decl.go.html#line-14" class="ident">subVW</a>(<label for="r91" class="ident">qhat</label>, <label for="r91" class="ident">qhat</label>, <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-831"><code>			<label for="r95" class="ident">c</label> := <a href="arith_decl.go.html#line-12" class="ident">subVV</a>(<label for="r92" class="ident">qhatv</label>[:<label for="r89" class="ident">s</label>], <label for="r92" class="ident">qhatv</label>[:<label for="r89" class="ident">s</label>], <label for="r81" class="ident">v</label>[:<label for="r89" class="ident">s</label>])</code></span>
<span class="codeline" id="line-832"><code>			<span class="keyword">if</span> <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r92" class="ident">qhatv</label>) &gt; <label for="r89" class="ident">s</label> {</code></span>
<span class="codeline" id="line-833"><code>				<a href="arith_decl.go.html#line-14" class="ident">subVW</a>(<label for="r92" class="ident">qhatv</label>[<label for="r89" class="ident">s</label>:], <label for="r92" class="ident">qhatv</label>[<label for="r89" class="ident">s</label>:], <label for="r95" class="ident">c</label>)</code></span>
<span class="codeline" id="line-834"><code>			}</code></span>
<span class="codeline" id="line-835"><code>			<a href="nat.go.html#line-377" class="ident">addAt</a>(<label for="r90" class="ident">uu</label>[<label for="r89" class="ident">s</label>:], <label for="r81" class="ident">v</label>[<label for="r89" class="ident">s</label>:], <span class="lit-number">0</span>)</code></span>
<span class="codeline" id="line-836"><code>		}</code></span>
<span class="codeline" id="line-837"><code>		<span class="keyword">if</span> <label for="r92" class="ident">qhatv</label>.<a href="nat.go.html#line-152" class="ident">cmp</a>(<label for="r90" class="ident">uu</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()) &gt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-838"><code>			<a href="../../../pkg/builtin.html#name-panic" class="ident">panic</a>(<span class="lit-string">"impossible"</span>)</code></span>
<span class="codeline" id="line-839"><code>		}</code></span>
<span class="codeline" id="line-840"><code>		<label for="r96" class="ident">c</label> := <a href="arith_decl.go.html#line-12" class="ident">subVV</a>(<label for="r90" class="ident">uu</label>[:<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r92" class="ident">qhatv</label>)], <label for="r90" class="ident">uu</label>[:<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r92" class="ident">qhatv</label>)], <label for="r92" class="ident">qhatv</label>)</code></span>
<span class="codeline" id="line-841"><code>		<span class="keyword">if</span> <label for="r96" class="ident">c</label> &gt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-842"><code>			<a href="arith_decl.go.html#line-14" class="ident">subVW</a>(<label for="r90" class="ident">uu</label>[<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r92" class="ident">qhatv</label>):], <label for="r90" class="ident">uu</label>[<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r92" class="ident">qhatv</label>):], <label for="r96" class="ident">c</label>)</code></span>
<span class="codeline" id="line-843"><code>		}</code></span>
<span class="codeline" id="line-844"><code>		<a href="nat.go.html#line-377" class="ident">addAt</a>(<label for="r78" class="ident">z</label>, <label for="r91" class="ident">qhat</label>, <label for="r88" class="ident">j</label>-<label for="r87" class="ident">B</label>)</code></span>
<span class="codeline" id="line-845"><code>		<label for="r88" class="ident">j</label> -= <label for="r87" class="ident">B</label></code></span>
<span class="codeline" id="line-846"><code>	}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>	<span class="comment">// TODO(rsc): Rewrite loop as described above and delete all this code.</span></code></span>
<span class="codeline" id="line-849"><code></code></span>
<span class="codeline" id="line-850"><code>	<span class="comment">// Now u &lt; (v&lt;&lt;B), compute lower bits in the same way.</span></code></span>
<span class="codeline" id="line-851"><code><span class="comment">	// Choose shift = B-1 again.</span></code></span>
<span class="codeline" id="line-852"><code>	<label for="r97" class="ident">s</label> := <label for="r87" class="ident">B</label> - <span class="lit-number">1</span></code></span>
<span class="codeline" id="line-853"><code>	<label for="r98" class="ident">qhat</label> := *<label for="r84" class="ident">temps</label>[<label for="r82" class="ident">depth</label>]</code></span>
<span class="codeline" id="line-854"><code>	<label for="r98" class="ident">qhat</label>.<a href="nat.go.html#line-43" class="ident">clear</a>()</code></span>
<span class="codeline" id="line-855"><code>	<label for="r98" class="ident">qhat</label>.<label for="r79" class="ident">divRecursiveStep</label>(<label for="r80" class="ident">u</label>[<label for="r97" class="ident">s</label>:].<a href="nat.go.html#line-49" class="ident">norm</a>(), <label for="r81" class="ident">v</label>[<label for="r97" class="ident">s</label>:], <label for="r82" class="ident">depth</label>+<span class="lit-number">1</span>, <label for="r83" class="ident">tmp</label>, <label for="r84" class="ident">temps</label>)</code></span>
<span class="codeline" id="line-856"><code>	<label for="r98" class="ident">qhat</label> = <label for="r98" class="ident">qhat</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()</code></span>
<span class="codeline" id="line-857"><code>	<label for="r99" class="ident">qhatv</label> := <label for="r83" class="ident">tmp</label>.<a href="nat.go.html#line-57" class="ident">make</a>(<span class="lit-number">3</span> * <label for="r85" class="ident">n</label>)</code></span>
<span class="codeline" id="line-858"><code>	<label for="r99" class="ident">qhatv</label>.<a href="nat.go.html#line-43" class="ident">clear</a>()</code></span>
<span class="codeline" id="line-859"><code>	<label for="r99" class="ident">qhatv</label> = <label for="r99" class="ident">qhatv</label>.<a href="nat.go.html#line-408" class="ident">mul</a>(<label for="r98" class="ident">qhat</label>, <label for="r81" class="ident">v</label>[:<label for="r97" class="ident">s</label>])</code></span>
<span class="codeline" id="line-860"><code>	<span class="comment">// Set the correct remainder as before.</span></code></span>
<span class="codeline" id="line-861"><code>	<span class="keyword">for</span> <label for="r100" class="ident">i</label> := <span class="lit-number">0</span>; <label for="r100" class="ident">i</label> &lt; <span class="lit-number">2</span>; <label for="r100" class="ident">i</label>++ {</code></span>
<span class="codeline" id="line-862"><code>		<span class="keyword">if</span> <label for="r101" class="ident">e</label> := <label for="r99" class="ident">qhatv</label>.<a href="nat.go.html#line-152" class="ident">cmp</a>(<label for="r80" class="ident">u</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()); <label for="r101" class="ident">e</label> &gt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-863"><code>			<a href="arith_decl.go.html#line-14" class="ident">subVW</a>(<label for="r98" class="ident">qhat</label>, <label for="r98" class="ident">qhat</label>, <span class="lit-number">1</span>)</code></span>
<span class="codeline" id="line-864"><code>			<label for="r102" class="ident">c</label> := <a href="arith_decl.go.html#line-12" class="ident">subVV</a>(<label for="r99" class="ident">qhatv</label>[:<label for="r97" class="ident">s</label>], <label for="r99" class="ident">qhatv</label>[:<label for="r97" class="ident">s</label>], <label for="r81" class="ident">v</label>[:<label for="r97" class="ident">s</label>])</code></span>
<span class="codeline" id="line-865"><code>			<span class="keyword">if</span> <a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r99" class="ident">qhatv</label>) &gt; <label for="r97" class="ident">s</label> {</code></span>
<span class="codeline" id="line-866"><code>				<a href="arith_decl.go.html#line-14" class="ident">subVW</a>(<label for="r99" class="ident">qhatv</label>[<label for="r97" class="ident">s</label>:], <label for="r99" class="ident">qhatv</label>[<label for="r97" class="ident">s</label>:], <label for="r102" class="ident">c</label>)</code></span>
<span class="codeline" id="line-867"><code>			}</code></span>
<span class="codeline" id="line-868"><code>			<a href="nat.go.html#line-377" class="ident">addAt</a>(<label for="r80" class="ident">u</label>[<label for="r97" class="ident">s</label>:], <label for="r81" class="ident">v</label>[<label for="r97" class="ident">s</label>:], <span class="lit-number">0</span>)</code></span>
<span class="codeline" id="line-869"><code>		}</code></span>
<span class="codeline" id="line-870"><code>	}</code></span>
<span class="codeline" id="line-871"><code>	<span class="keyword">if</span> <label for="r99" class="ident">qhatv</label>.<a href="nat.go.html#line-152" class="ident">cmp</a>(<label for="r80" class="ident">u</label>.<a href="nat.go.html#line-49" class="ident">norm</a>()) &gt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-872"><code>		<a href="../../../pkg/builtin.html#name-panic" class="ident">panic</a>(<span class="lit-string">"impossible"</span>)</code></span>
<span class="codeline" id="line-873"><code>	}</code></span>
<span class="codeline" id="line-874"><code>	<label for="r103" class="ident">c</label> := <a href="arith_decl.go.html#line-12" class="ident">subVV</a>(<label for="r80" class="ident">u</label>[<span class="lit-number">0</span>:<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r99" class="ident">qhatv</label>)], <label for="r80" class="ident">u</label>[<span class="lit-number">0</span>:<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r99" class="ident">qhatv</label>)], <label for="r99" class="ident">qhatv</label>)</code></span>
<span class="codeline" id="line-875"><code>	<span class="keyword">if</span> <label for="r103" class="ident">c</label> &gt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-876"><code>		<label for="r103" class="ident">c</label> = <a href="arith_decl.go.html#line-14" class="ident">subVW</a>(<label for="r80" class="ident">u</label>[<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r99" class="ident">qhatv</label>):], <label for="r80" class="ident">u</label>[<a href="../../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r99" class="ident">qhatv</label>):], <label for="r103" class="ident">c</label>)</code></span>
<span class="codeline" id="line-877"><code>	}</code></span>
<span class="codeline" id="line-878"><code>	<span class="keyword">if</span> <label for="r103" class="ident">c</label> &gt; <span class="lit-number">0</span> {</code></span>
<span class="codeline" id="line-879"><code>		<a href="../../../pkg/builtin.html#name-panic" class="ident">panic</a>(<span class="lit-string">"impossible"</span>)</code></span>
<span class="codeline" id="line-880"><code>	}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>	<span class="comment">// Done!</span></code></span>
<span class="codeline" id="line-883"><code>	<a href="nat.go.html#line-377" class="ident">addAt</a>(<label for="r78" class="ident">z</label>, <label for="r98" class="ident">qhat</label>.<a href="nat.go.html#line-49" class="ident">norm</a>(), <span class="lit-number">0</span>)</code></span>
<span class="codeline" id="line-884"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.5.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>